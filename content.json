{"meta":{"title":"小谈同学","subtitle":"","description":"小谈同学的博客","author":"Tab tan","url":"http://tab-tan.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-07-25T09:22:18.000Z","updated":"2020-07-25T09:22:32.305Z","comments":true,"path":"tags/index.html","permalink":"http://tab-tan.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-07-25T09:21:18.000Z","updated":"2020-07-25T09:21:54.984Z","comments":true,"path":"categories/index.html","permalink":"http://tab-tan.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"类的加载过程","slug":"类的加载过程","date":"2020-07-26T10:36:23.000Z","updated":"2020-07-26T12:18:27.077Z","comments":true,"path":"2020/07/26/类的加载过程/","link":"","permalink":"http://tab-tan.github.io/2020/07/26/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"","text":"类的加载过程类的加载有三大步 加载 链接 初始化 加载 通过类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 链接 验证(Verify) 目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。 准备(Prepare) 为类变量分配内存并且设置该变量的默认初始值，即零值。 这里不包括含用final修饰的static，因为final在编译的时候就会分配，准备阶段会显示初始化。 这里不会为实例变量分配初始化，变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。 解析(Resolve) 将常量池内的符号引用转换为直接引用的过程。 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。 初始化 初始化阶段就是执行类构造器方法()的过程。 此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 构造器方法中指令按语句在源文件中出现的顺序执行。 ()不同于类的构造器。(关联：构造器是虚拟机视角下的()) 若该类具有父类，JVM会保证子类的()执行前父类的()已经执行完毕。 虚拟机必须保证一个类的()方法在多线程下被同步加锁。 ###举例 初始化的最后一点意思是一个类只会被加载一次，我们来用代码对这句话进行验证。代码如下： 123456789101112131415161718192021222324252627public class DeadThread &#123; public static void main(String[] args) &#123; Runnable r = ()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\" 开始\"); new Dead(); System.out.println(Thread.currentThread().getName()+\" 结束\"); &#125;; new Thread(r,\"线程1\").start(); new Thread(r,\"线程2\").start(); &#125;&#125;class Dead&#123; static&#123; if (true)&#123; System.out.println(Thread.currentThread().getName()+\"正在进行初始化\"); while (true)&#123; &#125; &#125; &#125;&#125; 结果: 简单的说明一下，这里故意让Dead类无法正常的加载，然后起了两个线程去加载这个类。从结果来看线程2先来对Dead进行了加载，而在线程2没有加载完的情况下线程1没有去加载Dead类，验证了只会被加载一次。 理解类的加载得出答案 12345678910111213141516171819public class ClinitTest &#123; static class Father&#123; public static int A=1; static &#123; A=2; &#125; &#125; static class Sun extends Father&#123; public static int B=A; &#125; public static void main(String[] args) &#123; System.out.println(Sun.B); &#125;&#125; 结果: 说明在加载子类的时候会首先加载其父类，这里加载Sun的时候首先去加载了父类Father成员变量A的值由1变成2，当加载Sun时A的值为2，所以赋值给B，B的值为2","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/tags/JVM/"},{"name":"类的加载","slug":"类的加载","permalink":"http://tab-tan.github.io/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"}]},{"title":"多线程","slug":"多线程","date":"2020-07-25T13:09:08.000Z","updated":"2020-07-25T13:51:30.388Z","comments":true,"path":"2020/07/25/多线程/","link":"","permalink":"http://tab-tan.github.io/2020/07/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"多线程基础实现多线程的四种方式 继承Thread类 实现Runnable接口 实现Callable接口 使用线程池 常用方法 run(),start(),currentThread(),getName(),yield()(放弃cpu的当前执行权),wait(),notify()/notifyAll(),join()sleep(),isAlive(),stop()(已过时) 优先级 MAX_PRIORITY:10（Thread.MAX_PRIORITY）MIN_PRIORITY:1NORM_PRIORITY:5 线程的同步（线程的安全问题） 操作共享数据的代码，即为被同步的代码。 共享数据：多个线程抢夺的资源 同步监视器，俗称：锁。 Callable接口 实现类实现Callable接口 将实现类作为参数创建FutureTask 将FutureTask对象作为参数创建Thread并启动线程 代码： 1234567891011121314151617181920212223242526272829303132333435import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class CallableTest &#123; public static void main(String[] args) &#123; NumSum ns = new NumSum(); FutureTask f = new FutureTask(ns); new Thread(f).start(); Object object; try &#123; object = f.get(); System.out.println(object); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class NumSum implements Callable&#123; int sum = 0; @Override public Object call() throws Exception &#123; for(int i = 0 ; i&lt;50 ; i++) &#123; sum++; &#125; return sum; &#125;&#125; 结果： 线程池 JDK5.0提供线程池相关API：ExecutorService(接口)和Excutors(工具类) 常用方法： Executors.newFixedThreadPool(int i)创建固定数量的线程池。 excute()执行，无返回值 submit()执行，可以有返回值 shutdown()关闭线程池 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.FutureTask;public class ThreadPool &#123; public static void main(String[] args) &#123; MyTest myTest = new MyTest(); ExecutorService pool = Executors.newFixedThreadPool(10); pool.execute(new MyThread()); Future submit = pool.submit(myTest); Object object; try &#123; object = submit.get(); System.out.println(object); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; //关闭连接池 pool.isShutdown(); &#125;&#125;class MyTest implements Callable&#123; int m = 0; @Override public Object call() throws Exception &#123; for (int i = 0; i &lt; 50; i++) &#123; m++; &#125; return m; &#125; &#125;class MyThread implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(i); &#125; &#125; &#125; 结果： 设置线程池属性 corePoolSize:核心池大小maximumPoolSize:最大线程数keepAliveTime:无任务终止时间数","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"http://tab-tan.github.io/categories/Java-SE/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"多线程","slug":"多线程","permalink":"http://tab-tan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"搭建博客","slug":"搭建博客","date":"2020-07-25T11:40:38.000Z","updated":"2020-07-25T12:53:55.625Z","comments":true,"path":"2020/07/25/搭建博客/","link":"","permalink":"http://tab-tan.github.io/2020/07/25/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"环境github+hexo搭建个人博客 安装环境 安装nodejs 前往nodejs官网下载安装链接-http://nodejs.cn/download/ 安装hexo npm install -g hexo-cli(建议安装淘宝cnpm更快你懂的~) 创建博客文件夹 mkdir blog 如图: 初始化hexo 打开命令行进入创建好的blog命令行开始操作~hexo init 小操作 hexo n 博客标题:创建文章hexo clean | g(生成) | s(本地服务) 安装插件 npm install –save hexo-deployer-git 修改_config.yml文件 deploy:type: ‘git’repo: ‘https://github.com/Tab-Tan/Tab-tan.github.io.git&#39;branch: ‘master’ 远程部署 hexo d","categories":[{"name":"其他","slug":"其他","permalink":"http://tab-tan.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"搭建","slug":"搭建","permalink":"http://tab-tan.github.io/tags/%E6%90%AD%E5%BB%BA/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2020-07-24T11:09:03.000Z","updated":"2020-07-25T09:08:59.049Z","comments":true,"path":"2020/07/24/我的第一篇博客/","link":"","permalink":"http://tab-tan.github.io/2020/07/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"第一个博客也不知道说些什么 Java天下第一！ yeah~","categories":[{"name":"日常","slug":"日常","permalink":"http://tab-tan.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://tab-tan.github.io/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"hello-world","slug":"hello-world","date":"2020-07-24T10:01:59.985Z","updated":"2020-07-25T09:10:15.392Z","comments":true,"path":"2020/07/24/hello-world/","link":"","permalink":"http://tab-tan.github.io/2020/07/24/hello-world/","excerpt":"","text":"title: Hello WorldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/categories/JVM/"},{"name":"Java SE","slug":"Java-SE","permalink":"http://tab-tan.github.io/categories/Java-SE/"},{"name":"其他","slug":"其他","permalink":"http://tab-tan.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"日常","slug":"日常","permalink":"http://tab-tan.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/tags/JVM/"},{"name":"类的加载","slug":"类的加载","permalink":"http://tab-tan.github.io/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"},{"name":"多线程","slug":"多线程","permalink":"http://tab-tan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"搭建","slug":"搭建","permalink":"http://tab-tan.github.io/tags/%E6%90%AD%E5%BB%BA/"},{"name":"其他","slug":"其他","permalink":"http://tab-tan.github.io/tags/%E5%85%B6%E4%BB%96/"}]}