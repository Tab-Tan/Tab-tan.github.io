{"meta":{"title":"小谈同学","subtitle":"","description":"一个朝着成为架构师的梦想不断努力的boy","author":"Tab Tan","url":"http://tab-tan.gitee.io/tabtan","root":"/tabtan/"},"pages":[{"title":"categories","date":"2020-07-25T09:21:18.000Z","updated":"2020-07-25T09:21:54.984Z","comments":true,"path":"categories/index.html","permalink":"http://tab-tan.gitee.io/tabtan/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-07-25T09:22:18.000Z","updated":"2020-07-25T09:22:32.305Z","comments":true,"path":"tags/index.html","permalink":"http://tab-tan.gitee.io/tabtan/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"validate与国际化配合效果更加~","slug":"validate与国际化配合效果更加","date":"2022-03-06T03:16:18.000Z","updated":"2022-03-06T03:33:46.108Z","comments":true,"path":"2022/03/06/validate与国际化配合效果更加/","link":"","permalink":"http://tab-tan.gitee.io/tabtan/2022/03/06/validate%E4%B8%8E%E5%9B%BD%E9%99%85%E5%8C%96%E9%85%8D%E5%90%88%E6%95%88%E6%9E%9C%E6%9B%B4%E5%8A%A0/","excerpt":"","text":"前言：当我们用@valid或者@validate验证controller层接收前端发来的对象数据时，在对象的实体类上的validation相关的验证注解有起效了，很多时候我们会写message=“xxx”自定义验证不通过的内容。例如：@NotNull(message = &quot;id不能为空&quot;)很不优雅。点开源码可以看见默认的message,String message() default &quot;{javax.validation.constraints.NotNull.message}&quot;;,这就相当优雅了，设想我们有很多的业务有很多的业务提示，直接写死的话不够优雅，后期也不方便待修改，于是就有了这篇博客，使用国际化优雅的返回提示信息。本文从对validator和国际化的用法开始介绍。 validator数据验证 数据验证给了我们很多方便，避免了不少在接收完参数之后逐一验证参数的合法性所写的大量验证代码。 相关注解 @NotNull不为空 @NotBlank不为空白 NotEmpty至少有一个 @Range指定范围 @Length指定长度范围 @Min不能小于最小值 @Max不能大于最大值 @Email邮箱验证 @URL指定URL 还有很多注解可查看javax.validation和org.hibernate.validator包。 @Validated 和 @Valid@Valid和@Validated都可以用于验证,@Valid是JSR-303规范的注解，可以用在参数、属性、嵌套属性上，@Validated不能用在属性上。但@Validated支持分组。注解源码如下： 12345@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Valid &#123;&#125; 123456@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Validated &#123; Class&lt;?&gt;[] value() default &#123;&#125;;&#125; 自定义注解验证 可以自定义验证的注解，需要实现ConstraintValidator注解。以下写一个样例，功能是验证地址只能是自己的安全列表中的地址。 @MustIn: 12345678910@Target(&#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)@Constraint(validatedBy = MustInConstraintValidator.class)public @interface MustIn &#123; String message() default \"不可输入非法地址\"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; MustInConstraintValidator: 1234567891011121314151617public class MustInConstraintValidator implements ConstraintValidator&lt;MustIn,String&gt; &#123; private final String[] local = &#123;\"安徽\",\"淮南\",\"寿县\",\"北京\",\"合肥\",\"上海\"&#125;; private final Log logger = LogFactory.getLog(MustInConstraintValidator.class); @Override public void initialize(MustIn mustIn) &#123; logger.info(\"初始化自定义validate注解MustIn\"); &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; // 在local数组中就可 return \"\".equals(value) || Arrays.stream(local).parallel().anyMatch(e -&gt; e.equals(value)); &#125;&#125; 用法相关依赖: 不要直接cv，自己找一下对应的版本号。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- hibernate-validator --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- validation-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--java.el--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;$&#123;javax-el.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;javax.el&lt;/artifactId&gt; &lt;version&gt;$&#123;javax-el.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- hibernate --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- hibernate-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-envers&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-c3p0&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-proxool&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-ehcache&lt;/artifactId&gt; &lt;/dependency&gt; 实体类Student: 123456789101112131415161718@Data@AllArgsConstructor@NoArgsConstructorpublic class Student &#123; @NotNull(message = \"id不能为空\") private Long id; @NotNull(message = \"插入时,name不能为空\", groups = &#123;InsertGroup.class&#125;) @NotBlank(message = \"修改时,name不能为空\", groups = &#123;UpdateGroup.class&#125;) private String name; @MustIn(message = \"不可输入非法地址\") private String local; @Length(min = 11, max = 11, message = \"11位手机号\") private String tel;&#125; controller层DemoController: 1234567891011121314@RestController@RequestMapping(\"/demo\")public class DemoController &#123; @Autowired private MessageSource messageSource; private final Log logger = LogFactory.getLog(MustInConstraintValidator.class); @PostMapping(\"validate\") public void testValidator(@Validated(&#123;InsertGroup.class, Default.class&#125;) @RequestBody Student student)&#123; logger.info(student); &#125;&#125; 异常拦截(我直接返回字符串了，一般会封装一个响应类) 123456789@RestControllerAdvice(annotations = &#123;RestController.class, Controller.class&#125;)public class ExceptionHandle &#123; @ResponseStatus(HttpStatus.EXPECTATION_FAILED) @ExceptionHandler(MethodArgumentNotValidException.class) public String validate(MethodArgumentNotValidException e)&#123; return Objects.requireNonNull(e.getBindingResult().getFieldError()).getDefaultMessage(); &#125;&#125; postman测试一下下：ok 下面介绍国际化 国际化 springboot对国际化的支持很好，只需要简单的配置就可以实现。 1 引入依赖(省略)2 配置application.yml 123spring: messages: basename: i18n/test 3 创建国际化文件在basname指定的位置创建也就是在resources下创建i18n文件夹，在i18n中创建test.properties相关文件。 注意格式basename_local.properties是下划线。 4 配置类 123456789101112131415161718192021222324252627282930313233@Configurationpublic class ValidatorConfig &#123; @Autowired private MessageSource messageSource; /** * Description 配置validator&lt;br/&gt; * date 2022/3/4 10:47 &lt;br/&gt; * @author TabTan &lt;br/&gt; * @return Validator */ @Bean public Validator getValidator() &#123; LocalValidatorFactoryBean validator = new LocalValidatorFactoryBean(); validator.setValidationMessageSource(this.messageSource); return validator; &#125; /** * Description 配置本地解析器&lt;br/&gt; * date 2022/3/4 10:48 &lt;br/&gt; * @author TabTan &lt;br/&gt; * @return LocaleResolver */ @Bean public LocaleResolver localeResolver() &#123; AcceptHeaderLocaleResolver acceptHeaderLocaleResolver = new AcceptHeaderLocaleResolver(); // 设置默认的Local为中文 acceptHeaderLocaleResolver.setDefaultLocale(Locale.SIMPLIFIED_CHINESE); return acceptHeaderLocaleResolver; &#125;&#125; 5 国际化文件的内容： test.properties 1test = test test_en_US.properties 1test = hihi test_zh_CN.properties 1test = 嗨嗨 6 代码调用测试 1234567891011121314@RestController@RequestMapping(\"/demo\")public class DemoController &#123; @Autowired private MessageSource messageSource; private final Log logger = LogFactory.getLog(DemoController.class); @GetMapping(\"i18n\") public String i18nTest()&#123; return messageSource.getMessage(\"test\",null, LocaleContextHolder.getLocale()); &#125;&#125; postman 调用查看中文（配置类中的默认）英文（添加请求头Accept-Language值为en-US）注意en-US不是下划线 自定义业务验证提示国际化文件严重注解中的message可以指定国际化配置。如@NotNull(message = &quot;{student.idNotNull}&quot;)只需要在国际化配置中配置tudent.idNotNull即可。问题是所有的业务配置全部都写在一个国际化文件里岂不是很乱，很不优雅。最好是一个业务一个国际化配置。那么咋么实现呢？在配置文件中可以这样配置spring.messages.basename=i18n/test,i18n/student中间用逗号隔开。但直接在配置文件中这么写还是不够优雅。于是我动态加载了spring.messages.basename这一配置。只要在启动之初利用System.setProperty注入即可。我的思路是，启动时读取resources/i18n下的所有文件，然后将国际化配置文件拼接最后用System.setProperty注入即可。于是自定义启动插件类Launch,编写静态方法launcher()负责读取文件写入spring.messages.basename,在SpringBoot启动类的main方法开头添加 Launch.launcher();即可。代码如下： Launch类: 1234567891011121314151617181920212223242526272829303132333435363738394041/** * ClassName: launch &lt;br/&gt; * Description: &lt;br/&gt; * date: 2022/3/4 15:06 &lt;br/&gt; * author TabTan &lt;br/&gt; */public class Launch &#123; private static final Log logger = LogFactory.getLog(Launch.class); static &#123; logger.info(\"加载自定义启动组件\"); &#125; public static void launcher() &#123; // 加载国际化配置文件 setProps(); &#125; // 读取所有配置文件 添加国际化配置文件 @SneakyThrows private static void setProps() &#123; StringBuffer i18nValue = new StringBuffer(); File file = ResourceUtils.getFile(\"classpath:i18n\"); File[] properties = file.listFiles(f -&gt; f.getName().endsWith(\"properties\")); assert properties != null; Arrays.stream(properties) .parallel() .map(File::getName) .forEach(e -&gt; &#123; if (!e.contains(\"_\"))&#123; e = e.substring(0,e.indexOf(\".\")); i18nValue.append(\"i18n/\"); i18nValue.append(e); i18nValue.append(\",\"); &#125; &#125;); // 删除多余的逗号 i18nValue.deleteCharAt(i18nValue.length()-1); System.setProperty(\"spring.messages.basename\", String.valueOf(i18nValue)); logger.info(\"spring.messages.basename:\" + i18nValue); &#125;&#125; 启动类: 12345678@SpringBootApplicationpublic class FileDemoApplication &#123; public static void main(String[] args) &#123; //启动自定义组件 Launch.launcher(); SpringApplication.run(FileDemoApplication.class,args); &#125;&#125;","categories":[{"name":"springboot","slug":"springboot","permalink":"http://tab-tan.gitee.io/tabtan/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://tab-tan.gitee.io/tabtan/tags/springboot/"}]},{"title":"ElasticSearch+filebeat+logstash+kibana(版本7.14.0)","slug":"ElasticSearch-filebeat-logstash-kibana-版本7-14-0","date":"2022-03-05T14:08:27.000Z","updated":"2022-03-05T15:03:29.676Z","comments":true,"path":"2022/03/05/ElasticSearch-filebeat-logstash-kibana-版本7-14-0/","link":"","permalink":"http://tab-tan.gitee.io/tabtan/2022/03/05/ElasticSearch-filebeat-logstash-kibana-%E7%89%88%E6%9C%AC7-14-0/","excerpt":"","text":"环境与前言 centos7.x docker 20.x elk+filebeat 统一是7.14.0 本人大三，在一家小公司实习，最近公司里发版测试环境使用docker,觉得是时候学习一下docker了 于是学习了一下docker 不得不说上手之后很香。推荐到菜鸟教程学习，连接：Docker教程。学习完了部署了一下elk，也是在实习的时候接触到的，elk可以收集过滤分析日志，学习了一下。附上官网连接：ElasticSearch: 权威指南 Logstash 文档 Kibana 文档 Filebeat 文档 目前来说我只是单纯的使用，没有太过认真的去攻读这些文档，我只读了我用到的和一些配置的章节。以后有时间在慢慢学习下去吧，对这一块还算有点兴趣。 架构简介简介与他们之间的联系 Elasticsearch : 是一个分布式、RESTful 风格的搜索和数据分析引擎。 Logstash : 是免费且开放的服务器端数据处理管道，能够从多个来源采集数据，转换数据，然后将数据发送到您最喜欢的“存储库”中。 Kibana : 是一个免费且开放的用户界面，能够让您对 Elasticsearch 数据进行可视化，并让您在 Elastic Stack 中进行导航。您可以进行各种操作，从跟踪查询负载，到理解请求如何流经您的整个应用，都能轻松完成。 Filebeat : 无论是从安全设备、云、容器、主机还是 OT 进行数据收集，Filebeat 都将为您提供一种轻量型方法，用于转发和汇总日志与文件，让简单的事情不再繁杂。 联系草图： 描述： 通过filebeat从文件控制台等日志源中收集日志，发送给logstash,logstash进行过滤存储到elasticsearch,kibana重elasticsearch中读取数据进行分析处理等。 个人认为日志这东西是非常重要的，开发过程中程序跑不完善的日志可以快速排查定位错误原因。线上就更不用说了，没有错误日志咋死的都不知道。用过log4j的都说好，本次实验就使用log4j将日志输出到文本中。然后通过filebeat收集日志,再通过filebeat输出到logstash，logstash有过滤的能力,在通过logstash输出到elasticsearch进行存储，在通过Kibana查看分析什么的。废话讲完下面开始操作。 镜像下载 说明也许多年后的你看到这篇文章这里的很多东西都已经过时了，但整个流程应该不会相差甚远，希望能帮你找到真个思路而不是ctrl cv。 ElasticSearch docker 中查找镜像 docker search [你想找地镜像] 1docker search elasticearch 也可以去 Docker Hub 搜索: 点进去能看到版本号 我直接下载最新版7.14.0 1docker pull elasticearch:7.14.0 access denied for elasticearch, repository does not exist or may require ‘docker login’: denied: requested access to the resource is denied 报这个错你就docker login登录 至于没有账号就去注册。下面的下载都是这样不在赘述。 filebeat拉取镜像： 1docker pull docker.elastic.co/beats/filebeat:7.14.0 logstash拉取镜像： 1docker pull logstash:7.14.0 kibana拉取镜像： 1docker pull kibana:7.14.0 下载完成运行命令看一眼 1docker images 配置运行顺序说明 说一下，按我的习惯是按照依赖的顺序来启动的。聪明的你想按照什么顺序都一样。 1 . Elasticsearch启动1docker run -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" -d --net elk-net --name es elasticsearch:7.14.0 参数说明 : -p : 端口映射,将本机的9200映射到容器里的9200端口,访问localhost:9200就会访问到容器的9200. -e 环境变量 意思是将elasticsearch设置成单机运行 -d ： 后台运行,–net ：设置网络属于elk-net （你要是没有的话去简历或者不填这个配置）–name 设置容器的名字，不然的话默认一大串字母每次看日志还要ps一下多恶心你说是吧。 查看启动情况两种方式: docker ps -a STATUS 顾名思义状态,是UP就ok，不是的话使用第二种方式看启动日志看看报的什么错然后去百度怎么解决。 docker logs -f es 当然可以直接访问机器ip:9200查看有没有跑起来。 到此为止用来存储的Elasticsearch启动完成丢在一边就完事了。值得一提的是，写这篇文章的时候，作者仅仅在摸鱼时（实习除了crud还是想弄一弄其他东西的，嘎嘎嘎）刚搭建完成最基本的elk，能跑，有许多配置包括安全什么的作者都没有去配置，这仅仅只是一篇没有营养的搭建教程。 2 . Kibana编辑配置文件在本地新建一个kibana的配置文件对应kibana中的/config/kibana.yml 1234// 递归创建文件夹mkdir -p /home/docker/elk/kibana// 创建编辑配置文件vi /home/docker/elk/kibana/kibana.yml 这是kibana.yml内容: 1234server.host: \"0\"server.shutdownTimeout: \"5s\"elasticsearch.hosts: [ \"http://你的ip:9200\" ]monitoring.ui.container.elasticsearch.enabled: true 朋友，记得把‘’你的ip‘’换成你的机器ip 启动1docker run -v /home/docker/elk/kibana:/config -p 5601:5601 -d --net elk-net --name kibana kibana:7.14.0 参数解释: ：-v : 挂载本地的文件夹到容器中config文件夹 -p ： 端口映射 -d : 后台运行 --net ：将容器加入指定网络 --name ： 给容器起个名字。 查看启动效果 docker ps -a docker logs -f kibana 浏览器访问 http://你的ip:5601如果一切顺利你将看到如下画面: 小提示: 也许你在按照上面步骤ctrl cv之后并没有达到预期的效果,这是很正常的，生活总会事与愿违，你可能会看到页面一行没有准备好的英文,你在logs看到日志里有error告诉你elasticsearch节点信息查询不到等等等等。直接百度。作者也做过很多尝试,给你看看history，最后在es节点自测没有问题的情况下，我给你提供一个最终的解决方案。进入容器，直接修改容器里的配置文件，保存退出后重启容器,命令如下：进入容器:bash docker exec -it kibana /bin/bash打开/config/kibana.yml配置文件：bash vi /config/kibana.yml如果你打开看到elasticsearch.hosts: [ &quot;elasticsearch:9200&quot; ]那说明问题就出现在这,这是默认的，你只需要把elasticsearch改成你自己的地址,保存退出:wq输入exit退出容器,输入docker restart kibana重启容器即可。 至此elasticsearch和kibana启动完成。至于在kibana中操作查看es的内容自行百度，或者直接看官网也是可以的。下面是filebeat和logstash的启动： 3 . Logstash配置文件12345// 创建配置文件的文件夹mkdir -p /home/docker/elk/logstash/// 创建并编辑配置文件vim /home/docker/elk/logstash/logstash.ymlvim /home/docker/elk/logstash/logstash.conf logstash.yml 12http.host: \"0.0.0.0\"xpack.monitoring.elasticsearch.hosts: elasticsearch机器的ip:9200 logstash.conf 1234567891011121314input &#123; beats &#123; port &#x3D;&gt; 4567 &#125;&#125;filter &#123; #Only matched data are send to output.&#125;output &#123; elasticsearch &#123; hosts &#x3D;&gt; [&quot;http:&#x2F;&#x2F;elasticsearch机器ip:9200&quot;] #ElasticSearch host, can be array. index &#x3D;&gt; &quot;logapp-%&#123;+YYYY.MM&#125;&quot; #The index to write data to. &#125;&#125; 启动1docker run -d -p 4567:4567 --net elk-net --name logstash -p 5044:5044 -p 5045:5045 -v /home/docker/elk/logstash/logstash.conf:/usr/share/logstash/pipeline/logstash.conf -v /home/docker/elk/logstash/logstash.yml:/usr/share/logstash/config/logstash.yml logstash:7.14.0 小提示：配置文件中分为三个模块，input,filter,output很好理解，就是把东西通过input输入，通过filter过滤，通过output输出。其中input中的beats插件就是我们下面要启动的filebeat。filebeat通过4567端口将收集的日志发送给logstash,当然想用哪个端口随便你。启动完别忘了看看有没有启动成功,docker ps …,docker logs …. 4 . Filebeat配置文件新建需要收集的日志文件: 12mkdir -p /var/log/logappvim /var/log/logapp/app.info.log 然后在里面随便写点东西，我就写了一个test,真实环境中我们往往会收集nginx，java应用等的日志文件，这里我们就直接新建模拟一下了。 12mkdir -p /home/docker/elk/filebeat/vim /home/docker/elk/filebeat/filebeat.yml filebeat.yml 123456filebeat.inputs:- type: log paths: - /var/log/logapp/app.info.logoutput.logstash: hosts: [\"logstash的ip:4567\"] 注意：这里把你的ip换上去，这就是前面logstash配置文件input1中beats监听的端口。这里的缩进什么的都别丢了，严格按照yaml格式，不然就会报错。input中就是要收集的东西，我们收集一个刚刚我们新建的日志,paths里填上刚刚新建的日志文件的地址。 启动1docker run -u root -v /var/log/logapp:/var/log/logapp:rw -v /home/docker/elk/filebeat/filebeat.yml:/usr/share/filebeat/filebeat.yml:ro -e setup.kibana.host=你的kibana机器的ip:5601 -d --name filebeat --net elk-net docker.elastic.co/beats/filebeat:7.14.0 注意：记得把ip换成你的kibana的ip。到此全部正常的话就算是整合完成了。让我们打开kibana操作一波看一下效果。 查看效果浏览器输入http://kibana的ip:5601进入kibana： 选择管理： 选择索引配置： 创建： 输入之前配置文件中写的logapp下一步: 选择时间戳创建： 点击侧边栏，选择Discover： 选择刚刚创建的pattern： 这一条数据就是创建文件是写的test： 这时去echo写入一条hello elk回到kibana查看: 搜索一下： 好了，至此elk的基础搭建就完成了。至少是跑起来了，至于想要实现些什么，就去配置文件里配置就行。","categories":[{"name":"环境/工具","slug":"环境-工具","permalink":"http://tab-tan.gitee.io/tabtan/categories/%E7%8E%AF%E5%A2%83-%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"docker","slug":"docker","permalink":"http://tab-tan.gitee.io/tabtan/tags/docker/"}]},{"title":"服务调用之openFeign","slug":"服务调用之openFeign","date":"2021-01-17T10:44:10.000Z","updated":"2021-01-17T11:44:26.870Z","comments":true,"path":"2021/01/17/服务调用之openFeign/","link":"","permalink":"http://tab-tan.gitee.io/tabtan/2021/01/17/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E4%B9%8BopenFeign/","excerpt":"","text":"OpenFeign简介Feign 是一个声明式的Web服务客户端，让编写Web服务客户端变得非常容易，只需要创建一个接口并在接口上添加注解即可。 使用步骤application.yml 1234567server: port: 80eureka: client: register-with-eureka: false service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/ 主启动类添加注解@EnableFeignClients service层 123456789@Component@FeignClient(value = \"CLOUD-PAYMENT-SERVICE\")// *注明要调用的微服务名称public interface PaymentFeignService &#123; @PostMapping(\"/payment/create\") // *要调用的地址 public CommonResult&lt;Integer&gt; create(@RequestBody Payment payment); @GetMapping(\"/payment/get/&#123;id&#125;\") public CommonResult&lt;Payment&gt; queryOne(@PathVariable(\"id\") Long id);&#125; controller层 1234567891011@RestControllerpublic class OrderFeignController &#123; // 注入feign调用接口 @Resource private PaymentFeignService paymentFeignService; @GetMapping(\"/customer/payment/get/&#123;id&#125;\") public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(\"id\") Long id)&#123; return paymentFeignService.queryOne(id); &#125;&#125; 超时控制默认超时报错时间：1s application.yml 123456# 设置feign客户端超时时间（openFeign 默认支持 ribbon）ribbon: # 指的是建立连接使用的时间，适用于网络状况正常的情况下，两端的连接所用时间 ReadTimeout: 5000 # 指的是建立连接后从服务器读取到可用资源所用的时间 ConnectTimeout: 5000 日志增强日志级别 NONE：磨人的，不显示任何日志； BASIC：仅记录请求方法、URL、相应状态码及执行时间。 HEADERS：除了BASIC中定义的信息之外，还有请求和相应的头信息。 FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。 FeignConfig.class 12345678@Configurationpublic class FeignConfig &#123; @Bean Logger.Level feignLoggerLevel()&#123; return Logger.Level.FULL; &#125;&#125; application.yml 1234logging: level: # 哪个接口：什么级别 com.tan.service.PaymentFeignService: debug 总结 基本使用 主启动类加@EnableFeignClients Feign接口加@FeignClient(value = &quot;服务名称&quot;) Feign接口的方法头上加调用接口访问地址例如：@GetMapping(&quot;/payment/get/{id}&quot;) 超时控制 默认使用ribbon1s超时 在配置文件中配置超时时间，参数：ribbon.ReadTimeout、ribbon.ConnectTimeout 日志增强 配置类返回Logger.Level 配置文件开启debug，例如：logging.level.com.tan.service.PaymentFeignService=debug","categories":[{"name":"微服务","slug":"微服务","permalink":"http://tab-tan.gitee.io/tabtan/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://tab-tan.gitee.io/tabtan/tags/SpringCloud/"},{"name":"服务调用","slug":"服务调用","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"}]},{"title":"抽象工厂模式","slug":"抽象工厂模式","date":"2020-08-17T00:20:54.000Z","updated":"2020-08-17T01:56:50.967Z","comments":true,"path":"2020/08/17/抽象工厂模式/","link":"","permalink":"http://tab-tan.gitee.io/tabtan/2020/08/17/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。即工厂内造工厂。 优点&amp;&amp;缺点优点 产品族内的约束为非公开状态，在不同的工厂中各种产品之间可能具有不同的相互依赖关系，这些依赖关系由工厂封装在其内部，对于工厂的使用者来说这些依赖是不可见的。 生产线的扩展非常容易。如果要针对同一产品族建立新的生产线，只需实现产品族中的所有产品接口并建立新的工厂类即可。 缺点 产品族本身的扩展非常困难。如果产品族中增加一个新产品类型，则需要修改多个接口，并且会影响已有的工厂类。 抽象工厂实例实例已上传至github，附上地址:https://github.com/Tab-Tan/design/tree/master/factory/abstractFac","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://tab-tan.gitee.io/tabtan/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%9F%BA%E7%A1%80/"},{"name":"设计模式","slug":"设计模式","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"建造者模式","slug":"建造者模式","date":"2020-08-17T00:20:54.000Z","updated":"2020-08-17T02:09:42.197Z","comments":true,"path":"2020/08/17/建造者模式/","link":"","permalink":"http://tab-tan.gitee.io/tabtan/2020/08/17/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义建造者模式也叫生成器模式。将一个复杂的对象构建与它的表示分离，使得同样的构建过程可以构建不同的表示。 优点 封装性，使用建造者模式可以使客户端不必知道产品内部组成的细节。 建造者独立，容易扩展。 便于控制细节风险。由于具体的建造者是独立的，因此可以对建造者过程逐步细化，而不对其他模块产生任何影响。 建造者模式实例实例已上传至github，附上地址:https://github.com/Tab-Tan/design/tree/master/builder","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://tab-tan.gitee.io/tabtan/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%9F%BA%E7%A1%80/"},{"name":"设计模式","slug":"设计模式","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"方法区","slug":"方法区","date":"2020-07-29T13:16:09.000Z","updated":"2020-07-29T13:55:47.009Z","comments":true,"path":"2020/07/29/方法区/","link":"","permalink":"http://tab-tan.gitee.io/tabtan/2020/07/29/%E6%96%B9%E6%B3%95%E5%8C%BA/","excerpt":"","text":"方法区的基本理解 方法区(Method Area)与Java堆一样，是各个线程共享的内存区域。 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间和Java堆区一样都可以是不连续的。 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError:PermGen / Metaspace space 举例：加载大量的第三方jar包；Tomcat部署的过程过多(30-50个)；大量动态的生成反射类 关闭JVM就会释放这个区域的内存。 Hotspot中方法区的演进 jdk7及以前习惯把方法区称为永久代。jdk8使用元空间取代了永久代。 本质上，方法区和永久代并不等价。永久代仅是对hotspot而言。java虚拟机规范对如何实现方法区不作统一要求。 现在看来，当年使用永久代导致Java程序更容易OOM（超过-XX:MaxPermSize上限） 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存。 永久代、元空间并不只是名字变了，内部结构也调整了。 java虚拟机规范规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。 设置方法区大小 方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。 方法区(Method Area)存储什么？ 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码缓存等。 类型信息 对每个加载的类型(类class、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下类型信息： 这个类型的完整有效名称（全名=包名.类名） 这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类） 这个类型的修饰符(public , abstract , final的某个子集) 这个类型直接接口的一个有序列表 域（Field）信息 JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。 域的相关信息包括：域名称、域类型、域修饰符(public,private,protected,static,final,volatile,transient的某个子集) 方法（Method）信息 JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序： 方法名称 方法的返回类型(或 void) 方法参数的数量和类型(按顺序) 方法的修饰符(public,private,protected,static,final,synchronized,native,abstract的一个子集) 方法的字节码(bytecodes)、操作数栈、局部变量表及大小(abstract和native方法除外) 异常表（abstract和native除外） 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引 non-final的类变量 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分。 类变量被类的所有实例共享，即使没有类实例时你也可以访问它。 常量池中有什么？ 一个有效的字节码文件中除了包含版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表(Constant Pool Table)，包括各种字面量和对类型、域和方法的符号引用。 数值量 字符串值 类引用 字段引用 方法引用小结：常量池可以看做一张表，虚拟机指令根据这张表找到要执行的类名、方法名、参数类型、字面量等类型。 运行时常量池 方法区的一部分 常量池表是Class文件的一部分，用于存放编译期产生的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池。 JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组一样，是通过索引访问的。 运行时常量池中包含多种不同的常量，包含编译期就确定的数值字面量，也包括到运行期解析后才能获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。 运行时常量池相对于Class文件常量池的另一个重要特征：具备动态性 运行时常量池类似于穿统编程语言中的符号表(symbol table)，但是它所包含的数据却比符号表要更加丰富一些。 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的的最大值，则JVM会抛OutOfMemoryError异常。 方法区的演进细节(Hotspot) 首先明确，只有hotspot才有永久代。 hotspot中方法区的变化如下表： 版本 变化 jdk6及之前 有永久代(Permanent generation)，静态变量存放在永久代上 jdk7 有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中 jdk8及之后 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池，静态变量仍在堆 图示： 思考永久代为什么要被元空间替换？ 给永久代设置空间大小是很难确定的。 对永久代进行调优是很困难的。 StringTable为什么要调整？ jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。这就导致StringTable回收效率不高。而开发中大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆中，能及时回收内存。 方法区的垃圾收集 方法区内常量池中主要存放两大类常量：字面量和符号引用。 hotspot只要常量池中的常量没有被任何地方引用，就可以被回收。 回收废弃常量会回收Java堆中的对象非常类似. 判断类可回收的三个条件 该类的所有实例都已被回收,Java堆中不存在该类及其任何派生子类的实例。 加载该类的加载器已被回收,这个条件除非是经过精心设计的可替换加载器的场景,否则很难达成。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类方法。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.gitee.io/tabtan/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.gitee.io/tabtan/tags/JVM/"},{"name":"方法区","slug":"方法区","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E6%96%B9%E6%B3%95%E5%8C%BA/"}]},{"title":"堆区","slug":"堆区","date":"2020-07-28T23:38:30.000Z","updated":"2020-07-29T00:19:08.732Z","comments":true,"path":"2020/07/29/堆区/","link":"","permalink":"http://tab-tan.gitee.io/tabtan/2020/07/29/%E5%A0%86%E5%8C%BA/","excerpt":"","text":"堆的细分内存结构 现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为: Java 7及以前内存逻辑上分为三个部分：新生区+养老区+永久区 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Tenure generation Space 养老区 Old/Tenure Permanent Space 永久区 Perm Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Tenure generation Space 养老区 Old/Tenure Meta Space 元空间 Meta 约定：新生区=新生代=年轻代 | 养老区=老年区=老年代 | 永久区=永久代 堆空间大小的设置 Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。 “-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize “-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize 一旦堆区的内存大小超过”-Xmx”所指定的内存时，将会抛出OutOfMemoryError异常。 通常会将 -Xms和 -Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。 默认情况下，初始内存大小：物理电脑内存大小/64，最大内存大小：物理电脑内存大小/4 年轻代与老年代 配置新生代与老年代在堆结构的占比 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5 几乎所有的Java对象都是在Eden区被new出来的 绝大部分的Java对象的销毁都在新生代进行了 可以使用选项”-Xmn”设置新生代最大内存大小 这个参数一般使用默认值就可以了 对象的分配 对象分配总结: 针对幸存者s0，s1区：复制之后有交换，谁空谁是to 关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集 特殊情况 Minor GC Major GC Full GC JVM在进行GC时，并非每次都对上面三个内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大类型：一种是部分收集（Partial GC），一种是 整堆收集（Full GC） 部分收集 新生代收集(Minor GC/Young GC)：只是新生代(Eden,s0,s1)的垃圾收集 老年代收集(Major GC/Old GC)：只是老年代的垃圾收集 目前，只有CMS GC会有单独收集老年代的行为。 注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 目前只有G1 GC会有这种行为 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集 分代式GC策略的触发条件 年轻代GC(Minor GC)触发机制 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存） 因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度比较快。 Minor GC会引发STW，暂停其他用户线程，等垃圾回收结束，用户线程才恢复运行 老年代GC（Major GC/Full GC）触发机制 发生在老年代的GC，对象从老年代消失时，Major GC或Full GC发生了 出现了major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程） 也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足则会触发Major GC Major GC的速度一般比Minor GC慢10倍以上，STW的时间更长 如果Major GC后内存还不足则OOM（内存溢出） Full GC触发机制（提出去） 调用System.gc()时，系统建议执行Full GC，但是不必然执行 老年代空间不足 方法区空间不足 通过Minor GC后进入老年代的平均大小大于老年代的可用内存 由Eden区、survivor space0（From Space）区向survivor space1(To Space)区复制时，对象大小大于To Space可用内存，则把对象转存到老年代，且老年代的可用内存大小小于该对象大小 说明：Full GC是开发或调优中尽量要避免的。这样暂停时间会短一些。 对象分配过程：TLAB为什么有TLAB（Thread Local Allocation Buffer）? 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据 由于对象实例的创建在JVM中非常频繁，因为在并发环境下从堆区中划分内存空间是线程不安全的 为避免多个线程操作同一个地址，需要使用加锁等机制，进而影响分配速度。什么是TLAB？ 从内存模型而不是垃圾收集的角度，堆Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因为我们可以将这种内存分配方式称之为快速分配策略。 OpenJDK衍生出来的JVM都提供了TLAB的设计。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.gitee.io/tabtan/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.gitee.io/tabtan/tags/JVM/"},{"name":"堆","slug":"堆","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%A0%86/"}]},{"title":"方法引用","slug":"方法引用","date":"2020-07-27T23:36:04.000Z","updated":"2020-07-27T23:58:32.279Z","comments":true,"path":"2020/07/28/方法引用/","link":"","permalink":"http://tab-tan.gitee.io/tabtan/2020/07/28/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/","excerpt":"","text":"引入：在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。 以下介绍关于方法引用的概念 方法的静态链接与动态链接 静态链接一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期间可知，且运行期间保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程叫做静态链接。 动态链接如果被调用的方法在编译期间无法确定，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称为动态链接。 早期绑定与晚期绑定 早期绑定被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。 晚期绑定如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。 非虚方法与虚方法 编译期就确定了具体的调用版本，这个版本在运行时是不可变的。 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。 其他的都是虚方法。 虚拟机中提供了以下几条方法调用指令 普通调用指令 invokestatic：调用静态方法，解析阶段确定唯一方法版本 invokespecial：调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本 invokevirtual：调用所有虚方法 invokeinterface：调用接口方法 动态调用指令 invokedynamic：动态解析出需要调用的方法，然后执行 前四条指令固化在虚拟机内部，方法的调用执行不可认为干预，而invokedynamic指令则支持用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的(final修饰的除外)称为虚方法。 虚方法表 虚方法表：为了提高性能，在类的加载中的解析的环节创建。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.gitee.io/tabtan/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.gitee.io/tabtan/tags/JVM/"},{"name":"栈","slug":"栈","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E6%A0%88/"}]},{"title":"虚拟机栈","slug":"虚拟机栈","date":"2020-07-27T14:50:12.000Z","updated":"2020-07-27T23:34:03.259Z","comments":true,"path":"2020/07/27/虚拟机栈/","link":"","permalink":"http://tab-tan.gitee.io/tabtan/2020/07/27/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/","excerpt":"","text":"调整虚拟机栈的大小的参数 -Xss 栈的结构栈有一个个栈帧组成|–栈|—-|–栈帧|—-|—-|–局部变量表|—-|—-|–操作数栈|—-|—-|–方法返回地址|—-|—-|–动态链接|—-|—-|–一些附加信息 如图： 局部变量表 也被称为局表变量数组或本地变量表，是一个数字数组。 记录基本数据类型和对象的引用和返回值类型。 局部变量表的大小在编译器就被确定不会改变。 基本存储单元：slot（变量槽） 32位以内的类型只占用一个槽，64位（long、double）占用两个槽 实例方法中局部变量表的首位存放this 注意solt重复利用的问题 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部 变量表中直接或间接引用的对象都不会被回收。 操作数栈 主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间 方法刚执行的时候，一个新的栈帧会被创建，这个方法的操作数栈是空的 如果调用的方法带有返回值，返回值会被压入当前栈帧的操作数栈 操作数栈有明确的长度，为方法的code属性中的max_stack的值 操作数栈并非采用索引的方式来进行数据访问 JVM的解释引擎是基于栈的执行引擎，其中的栈指的是操作数栈 动态链接（指向运行时常量池的方法引用） 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。 动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。 方法调用（提出去）方法返回地址 存储该方法PC寄存器的值 一个方法的结束有两种方式 正常执行结束 出现未处理异常，非正常退出 无论通过哪种方式退出，在方法退出后都会返回该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存着部分信息。 一些附加信息 栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如对程序调试提供支持的信息。 其中方法返回地址、动态链接、一些附加信息称为帧数据区","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.gitee.io/tabtan/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.gitee.io/tabtan/tags/JVM/"},{"name":"栈","slug":"栈","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E6%A0%88/"}]},{"title":"类加载器","slug":"类加载器","date":"2020-07-27T01:48:27.000Z","updated":"2020-07-27T02:37:25.275Z","comments":true,"path":"2020/07/27/类加载器/","link":"","permalink":"http://tab-tan.gitee.io/tabtan/2020/07/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/","excerpt":"","text":"各层级类加载器的关系 ClassLoader的继承树 类加载器的分类虚拟机自带的加载器 启动类加载器（引导类加载器 Bootstrap ClassLoader） 使用c/c++实现的，嵌套在JVM内部 用来加载Java的核心库，用于提供JVM自身需要的类 并不继承自java.lang.ClassLoader，没有父加载器 加载扩展类和应用程序类加载器，并指定为他们的父类加载器 只加载包名为java、javax、sun等开头的类 扩展类加载器（Extension ClassLoader） Java编写，由sun.misc.Launcher$ExtClassLoader实现 派生于ClassLoader类 父类加载器为启动类加载器 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。 应用程序类加载器（系统类加载器 AppClassLoader） java编写，由sun.misc.Launcher$AppClassLoader实现 派生于ClassLoader类 父类加载器为扩展类加载器 负责加载环境变量classpath或系统属性java.class.path指定路径下的类库 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器 用户自定义类加载器 为什么要自定义类的加载器？ 隔离加载类 修改类加载方式 扩展加载源 防止源码泄漏 实现步骤 ClassLoader ClassLoader类，他是一个抽象类，其后所有的类加载器都继承自ClassLoader(不包括启动类加载器) 常用方法如下表: 方法 描述 getParent() 返回该类加载器的超类加载器 loadClass(String name) 加载名称为name的类，返回java.lang.Class类的实例 findClass(String name) 查找名为name的类，返回java.lang.Class类的实例 findLoadedClass(String name) 查找名为name的已经被加载过的类，返回结果为java.lang.Class类的实例 defineClass(String name,byte[] b,int off,int len) 把字节数组b中的内容转换为一个java类，返回结果为java.lang.Class类的实例 resolveClass(Class&lt;?&gt;c) 链接指定的一个java类","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.gitee.io/tabtan/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.gitee.io/tabtan/tags/JVM/"},{"name":"类加载器","slug":"类加载器","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"}]},{"title":"双亲委派机制","slug":"双亲委派机制","date":"2020-07-27T01:13:20.000Z","updated":"2020-07-27T01:47:28.420Z","comments":true,"path":"2020/07/27/双亲委派机制/","link":"","permalink":"http://tab-tan.gitee.io/tabtan/2020/07/27/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/","excerpt":"","text":"引入 Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。 双亲委派机制工作原理 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行 如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器 如果父类加载器可以完成加载任务，就成功返回，若不能完成则子加载器才会尝试自己加载 图示： 双亲委派机制优势 避免类的重复加载 保护程序安全，防止核心API被随意篡改 沙箱安全机制 在加载类的时候遇到用户自定义如java.lang包的类时，这个类会被委派到引导类加载器。引导类加载器会对此类进行校验，假如此类不是核心库中的类则会直接报错终止程序。这种安全校验就是沙箱安全机制，对jvm和程序起到了保护作用。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.gitee.io/tabtan/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.gitee.io/tabtan/tags/JVM/"},{"name":"机制","slug":"机制","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E6%9C%BA%E5%88%B6/"}]},{"title":"类的加载过程","slug":"类的加载过程","date":"2020-07-26T10:36:23.000Z","updated":"2020-07-26T23:24:36.983Z","comments":true,"path":"2020/07/26/类的加载过程/","link":"","permalink":"http://tab-tan.gitee.io/tabtan/2020/07/26/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"","text":"类的加载过程类的加载有三大步 加载 链接 初始化 加载 通过类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 链接 验证(Verify) 目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。 准备(Prepare) 为类变量分配内存并且设置该变量的默认初始值，即零值。 这里不包括含用final修饰的static，因为final在编译的时候就会分配，准备阶段会显示初始化。 这里不会为实例变量分配初始化，变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。 解析(Resolve) 将常量池内的符号引用转换为直接引用的过程。 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。 初始化 初始化阶段就是执行类构造器方法()的过程。 此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 构造器方法中指令按语句在源文件中出现的顺序执行。 ()不同于类的构造器。(关联：构造器是虚拟机视角下的()) 若该类具有父类，JVM会保证子类的()执行前父类的()已经执行完毕。 虚拟机必须保证一个类的()方法在多线程下被同步加锁。 举例 初始化的最后一点意思是一个类只会被加载一次，我们来用代码对这句话进行验证。代码如下： 123456789101112131415161718192021222324252627public class DeadThread &#123; public static void main(String[] args) &#123; Runnable r = ()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\" 开始\"); new Dead(); System.out.println(Thread.currentThread().getName()+\" 结束\"); &#125;; new Thread(r,\"线程1\").start(); new Thread(r,\"线程2\").start(); &#125;&#125;class Dead&#123; static&#123; if (true)&#123; System.out.println(Thread.currentThread().getName()+\"正在进行初始化\"); while (true)&#123; &#125; &#125; &#125;&#125; 结果: 简单的说明一下，这里故意让Dead类无法正常的加载，然后起了两个线程去加载这个类。从结果来看线程2先来对Dead进行了加载，而在线程2没有加载完的情况下线程1没有去加载Dead类，验证了只会被加载一次。 理解类的加载得出答案 12345678910111213141516171819public class ClinitTest &#123; static class Father&#123; public static int A=1; static &#123; A=2; &#125; &#125; static class Sun extends Father&#123; public static int B=A; &#125; public static void main(String[] args) &#123; System.out.println(Sun.B); &#125;&#125; 结果: 说明在加载子类的时候会首先加载其父类，这里加载Sun的时候首先去加载了父类Father成员变量A的值由1变成2，当加载Sun时A的值为2，所以赋值给B，B的值为2","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.gitee.io/tabtan/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.gitee.io/tabtan/tags/JVM/"},{"name":"类的加载","slug":"类的加载","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"}]},{"title":"多线程","slug":"多线程","date":"2020-07-25T13:09:08.000Z","updated":"2020-07-25T13:51:30.388Z","comments":true,"path":"2020/07/25/多线程/","link":"","permalink":"http://tab-tan.gitee.io/tabtan/2020/07/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"多线程基础实现多线程的四种方式 继承Thread类 实现Runnable接口 实现Callable接口 使用线程池 常用方法 run(),start(),currentThread(),getName(),yield()(放弃cpu的当前执行权),wait(),notify()/notifyAll(),join()sleep(),isAlive(),stop()(已过时) 优先级 MAX_PRIORITY:10（Thread.MAX_PRIORITY）MIN_PRIORITY:1NORM_PRIORITY:5 线程的同步（线程的安全问题） 操作共享数据的代码，即为被同步的代码。 共享数据：多个线程抢夺的资源 同步监视器，俗称：锁。 Callable接口 实现类实现Callable接口 将实现类作为参数创建FutureTask 将FutureTask对象作为参数创建Thread并启动线程 代码： 1234567891011121314151617181920212223242526272829303132333435import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class CallableTest &#123; public static void main(String[] args) &#123; NumSum ns = new NumSum(); FutureTask f = new FutureTask(ns); new Thread(f).start(); Object object; try &#123; object = f.get(); System.out.println(object); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class NumSum implements Callable&#123; int sum = 0; @Override public Object call() throws Exception &#123; for(int i = 0 ; i&lt;50 ; i++) &#123; sum++; &#125; return sum; &#125;&#125; 结果： 线程池 JDK5.0提供线程池相关API：ExecutorService(接口)和Excutors(工具类) 常用方法： Executors.newFixedThreadPool(int i)创建固定数量的线程池。 excute()执行，无返回值 submit()执行，可以有返回值 shutdown()关闭线程池 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.FutureTask;public class ThreadPool &#123; public static void main(String[] args) &#123; MyTest myTest = new MyTest(); ExecutorService pool = Executors.newFixedThreadPool(10); pool.execute(new MyThread()); Future submit = pool.submit(myTest); Object object; try &#123; object = submit.get(); System.out.println(object); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; //关闭连接池 pool.isShutdown(); &#125;&#125;class MyTest implements Callable&#123; int m = 0; @Override public Object call() throws Exception &#123; for (int i = 0; i &lt; 50; i++) &#123; m++; &#125; return m; &#125; &#125;class MyThread implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(i); &#125; &#125; &#125; 结果： 设置线程池属性 corePoolSize:核心池大小maximumPoolSize:最大线程数keepAliveTime:无任务终止时间数","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"http://tab-tan.gitee.io/tabtan/categories/Java-SE/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%9F%BA%E7%A1%80/"},{"name":"多线程","slug":"多线程","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"搭建博客","slug":"搭建博客","date":"2020-07-25T11:40:38.000Z","updated":"2020-07-25T12:53:55.625Z","comments":true,"path":"2020/07/25/搭建博客/","link":"","permalink":"http://tab-tan.gitee.io/tabtan/2020/07/25/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"环境github+hexo搭建个人博客 安装环境 安装nodejs 前往nodejs官网下载安装链接-http://nodejs.cn/download/ 安装hexo npm install -g hexo-cli(建议安装淘宝cnpm更快你懂的~) 创建博客文件夹 mkdir blog 如图: 初始化hexo 打开命令行进入创建好的blog命令行开始操作~hexo init 小操作 hexo n 博客标题:创建文章hexo clean | g(生成) | s(本地服务) 安装插件 npm install –save hexo-deployer-git 修改_config.yml文件 deploy:type: ‘git’repo: ‘https://github.com/Tab-Tan/Tab-tan.github.io.git&#39;branch: ‘master’ 远程部署 hexo d","categories":[{"name":"其他","slug":"其他","permalink":"http://tab-tan.gitee.io/tabtan/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"搭建","slug":"搭建","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E6%90%AD%E5%BB%BA/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2020-07-24T11:09:03.000Z","updated":"2020-07-25T09:08:59.049Z","comments":true,"path":"2020/07/24/我的第一篇博客/","link":"","permalink":"http://tab-tan.gitee.io/tabtan/2020/07/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"第一个博客也不知道说些什么 Java天下第一！ yeah~","categories":[{"name":"日常","slug":"日常","permalink":"http://tab-tan.gitee.io/tabtan/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%85%B6%E4%BB%96/"}]}],"categories":[{"name":"springboot","slug":"springboot","permalink":"http://tab-tan.gitee.io/tabtan/categories/springboot/"},{"name":"环境/工具","slug":"环境-工具","permalink":"http://tab-tan.gitee.io/tabtan/categories/%E7%8E%AF%E5%A2%83-%E5%B7%A5%E5%85%B7/"},{"name":"微服务","slug":"微服务","permalink":"http://tab-tan.gitee.io/tabtan/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"设计模式","slug":"设计模式","permalink":"http://tab-tan.gitee.io/tabtan/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.gitee.io/tabtan/categories/JVM/"},{"name":"Java SE","slug":"Java-SE","permalink":"http://tab-tan.gitee.io/tabtan/categories/Java-SE/"},{"name":"其他","slug":"其他","permalink":"http://tab-tan.gitee.io/tabtan/categories/%E5%85%B6%E4%BB%96/"},{"name":"日常","slug":"日常","permalink":"http://tab-tan.gitee.io/tabtan/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://tab-tan.gitee.io/tabtan/tags/springboot/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"docker","slug":"docker","permalink":"http://tab-tan.gitee.io/tabtan/tags/docker/"},{"name":"微服务","slug":"微服务","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://tab-tan.gitee.io/tabtan/tags/SpringCloud/"},{"name":"服务调用","slug":"服务调用","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"},{"name":"基础","slug":"基础","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%9F%BA%E7%A1%80/"},{"name":"设计模式","slug":"设计模式","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.gitee.io/tabtan/tags/JVM/"},{"name":"方法区","slug":"方法区","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E6%96%B9%E6%B3%95%E5%8C%BA/"},{"name":"堆","slug":"堆","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%A0%86/"},{"name":"栈","slug":"栈","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E6%A0%88/"},{"name":"类加载器","slug":"类加载器","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"name":"机制","slug":"机制","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E6%9C%BA%E5%88%B6/"},{"name":"类的加载","slug":"类的加载","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"},{"name":"多线程","slug":"多线程","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"搭建","slug":"搭建","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E6%90%AD%E5%BB%BA/"},{"name":"其他","slug":"其他","permalink":"http://tab-tan.gitee.io/tabtan/tags/%E5%85%B6%E4%BB%96/"}]}