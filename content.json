{"meta":{"title":"小谈同学","subtitle":"","description":"小谈同学的博客","author":"Tab tan","url":"http://tab-tan.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-07-25T09:21:18.000Z","updated":"2020-07-25T09:21:54.984Z","comments":true,"path":"categories/index.html","permalink":"http://tab-tan.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-07-25T09:22:18.000Z","updated":"2020-07-25T09:22:32.305Z","comments":true,"path":"tags/index.html","permalink":"http://tab-tan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"方法区","slug":"方法区","date":"2020-07-29T13:16:09.000Z","updated":"2020-07-29T13:55:47.009Z","comments":true,"path":"2020/07/29/方法区/","link":"","permalink":"http://tab-tan.github.io/2020/07/29/%E6%96%B9%E6%B3%95%E5%8C%BA/","excerpt":"","text":"方法区的基本理解 方法区(Method Area)与Java堆一样，是各个线程共享的内存区域。 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间和Java堆区一样都可以是不连续的。 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError:PermGen / Metaspace space 举例：加载大量的第三方jar包；Tomcat部署的过程过多(30-50个)；大量动态的生成反射类 关闭JVM就会释放这个区域的内存。 Hotspot中方法区的演进 jdk7及以前习惯把方法区称为永久代。jdk8使用元空间取代了永久代。 本质上，方法区和永久代并不等价。永久代仅是对hotspot而言。java虚拟机规范对如何实现方法区不作统一要求。 现在看来，当年使用永久代导致Java程序更容易OOM（超过-XX:MaxPermSize上限） 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存。 永久代、元空间并不只是名字变了，内部结构也调整了。 java虚拟机规范规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。 设置方法区大小 方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。 方法区(Method Area)存储什么？ 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码缓存等。 类型信息 对每个加载的类型(类class、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下类型信息： 这个类型的完整有效名称（全名=包名.类名） 这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类） 这个类型的修饰符(public , abstract , final的某个子集) 这个类型直接接口的一个有序列表 域（Field）信息 JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。 域的相关信息包括：域名称、域类型、域修饰符(public,private,protected,static,final,volatile,transient的某个子集) 方法（Method）信息 JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序： 方法名称 方法的返回类型(或 void) 方法参数的数量和类型(按顺序) 方法的修饰符(public,private,protected,static,final,synchronized,native,abstract的一个子集) 方法的字节码(bytecodes)、操作数栈、局部变量表及大小(abstract和native方法除外) 异常表（abstract和native除外） 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引 non-final的类变量 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分。 类变量被类的所有实例共享，即使没有类实例时你也可以访问它。 常量池中有什么？ 一个有效的字节码文件中除了包含版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表(Constant Pool Table)，包括各种字面量和对类型、域和方法的符号引用。 数值量 字符串值 类引用 字段引用 方法引用小结：常量池可以看做一张表，虚拟机指令根据这张表找到要执行的类名、方法名、参数类型、字面量等类型。 运行时常量池 方法区的一部分 常量池表是Class文件的一部分，用于存放编译期产生的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池。 JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组一样，是通过索引访问的。 运行时常量池中包含多种不同的常量，包含编译期就确定的数值字面量，也包括到运行期解析后才能获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。 运行时常量池相对于Class文件常量池的另一个重要特征：具备动态性 运行时常量池类似于穿统编程语言中的符号表(symbol table)，但是它所包含的数据却比符号表要更加丰富一些。 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的的最大值，则JVM会抛OutOfMemoryError异常。 方法区的演进细节(Hotspot) 首先明确，只有hotspot才有永久代。 hotspot中方法区的变化如下表： 版本 变化 jdk6及之前 有永久代(Permanent generation)，静态变量存放在永久代上 jdk7 有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中 jdk8及之后 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池，静态变量仍在堆 图示： 思考永久代为什么要被元空间替换？ 给永久代设置空间大小是很难确定的。 对永久代进行调优是很困难的。 StringTable为什么要调整？ jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。这就导致StringTable回收效率不高。而开发中大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆中，能及时回收内存。 方法区的垃圾收集 方法区内常量池中主要存放两大类常量：字面量和符号引用。 hotspot只要常量池中的常量没有被任何地方引用，就可以被回收。 回收废弃常量会回收Java堆中的对象非常类似. 判断类可回收的三个条件 该类的所有实例都已被回收,Java堆中不存在该类及其任何派生子类的实例。 加载该类的加载器已被回收,这个条件除非是经过精心设计的可替换加载器的场景,否则很难达成。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类方法。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/tags/JVM/"},{"name":"方法区","slug":"方法区","permalink":"http://tab-tan.github.io/tags/%E6%96%B9%E6%B3%95%E5%8C%BA/"}]},{"title":"堆区","slug":"堆区","date":"2020-07-28T23:38:30.000Z","updated":"2020-07-29T00:19:08.732Z","comments":true,"path":"2020/07/29/堆区/","link":"","permalink":"http://tab-tan.github.io/2020/07/29/%E5%A0%86%E5%8C%BA/","excerpt":"","text":"堆的细分内存结构 现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为: Java 7及以前内存逻辑上分为三个部分：新生区+养老区+永久区 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Tenure generation Space 养老区 Old/Tenure Permanent Space 永久区 Perm Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Tenure generation Space 养老区 Old/Tenure Meta Space 元空间 Meta 约定：新生区=新生代=年轻代 | 养老区=老年区=老年代 | 永久区=永久代 堆空间大小的设置 Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。 “-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize “-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize 一旦堆区的内存大小超过”-Xmx”所指定的内存时，将会抛出OutOfMemoryError异常。 通常会将 -Xms和 -Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。 默认情况下，初始内存大小：物理电脑内存大小/64，最大内存大小：物理电脑内存大小/4 年轻代与老年代 配置新生代与老年代在堆结构的占比 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5 几乎所有的Java对象都是在Eden区被new出来的 绝大部分的Java对象的销毁都在新生代进行了 可以使用选项”-Xmn”设置新生代最大内存大小 这个参数一般使用默认值就可以了 对象的分配 对象分配总结: 针对幸存者s0，s1区：复制之后有交换，谁空谁是to 关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集 特殊情况 Minor GC Major GC Full GC JVM在进行GC时，并非每次都对上面三个内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大类型：一种是部分收集（Partial GC），一种是 整堆收集（Full GC） 部分收集 新生代收集(Minor GC/Young GC)：只是新生代(Eden,s0,s1)的垃圾收集 老年代收集(Major GC/Old GC)：只是老年代的垃圾收集 目前，只有CMS GC会有单独收集老年代的行为。 注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 目前只有G1 GC会有这种行为 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集 分代式GC策略的触发条件 年轻代GC(Minor GC)触发机制 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存） 因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度比较快。 Minor GC会引发STW，暂停其他用户线程，等垃圾回收结束，用户线程才恢复运行 老年代GC（Major GC/Full GC）触发机制 发生在老年代的GC，对象从老年代消失时，Major GC或Full GC发生了 出现了major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程） 也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足则会触发Major GC Major GC的速度一般比Minor GC慢10倍以上，STW的时间更长 如果Major GC后内存还不足则OOM（内存溢出） Full GC触发机制（提出去） 调用System.gc()时，系统建议执行Full GC，但是不必然执行 老年代空间不足 方法区空间不足 通过Minor GC后进入老年代的平均大小大于老年代的可用内存 由Eden区、survivor space0（From Space）区向survivor space1(To Space)区复制时，对象大小大于To Space可用内存，则把对象转存到老年代，且老年代的可用内存大小小于该对象大小 说明：Full GC是开发或调优中尽量要避免的。这样暂停时间会短一些。 对象分配过程：TLAB为什么有TLAB（Thread Local Allocation Buffer）? 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据 由于对象实例的创建在JVM中非常频繁，因为在并发环境下从堆区中划分内存空间是线程不安全的 为避免多个线程操作同一个地址，需要使用加锁等机制，进而影响分配速度。什么是TLAB？ 从内存模型而不是垃圾收集的角度，堆Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因为我们可以将这种内存分配方式称之为快速分配策略。 OpenJDK衍生出来的JVM都提供了TLAB的设计。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/tags/JVM/"},{"name":"堆","slug":"堆","permalink":"http://tab-tan.github.io/tags/%E5%A0%86/"}]},{"title":"方法引用","slug":"方法引用","date":"2020-07-27T23:36:04.000Z","updated":"2020-07-27T23:58:32.279Z","comments":true,"path":"2020/07/28/方法引用/","link":"","permalink":"http://tab-tan.github.io/2020/07/28/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/","excerpt":"","text":"引入：在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。 以下介绍关于方法引用的概念 方法的静态链接与动态链接 静态链接一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期间可知，且运行期间保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程叫做静态链接。 动态链接如果被调用的方法在编译期间无法确定，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称为动态链接。 早期绑定与晚期绑定 早期绑定被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。 晚期绑定如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。 非虚方法与虚方法 编译期就确定了具体的调用版本，这个版本在运行时是不可变的。 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。 其他的都是虚方法。 虚拟机中提供了以下几条方法调用指令 普通调用指令 invokestatic：调用静态方法，解析阶段确定唯一方法版本 invokespecial：调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本 invokevirtual：调用所有虚方法 invokeinterface：调用接口方法 动态调用指令 invokedynamic：动态解析出需要调用的方法，然后执行 前四条指令固化在虚拟机内部，方法的调用执行不可认为干预，而invokedynamic指令则支持用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的(final修饰的除外)称为虚方法。 虚方法表 虚方法表：为了提高性能，在类的加载中的解析的环节创建。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/tags/JVM/"},{"name":"栈","slug":"栈","permalink":"http://tab-tan.github.io/tags/%E6%A0%88/"}]},{"title":"虚拟机栈","slug":"虚拟机栈","date":"2020-07-27T14:50:12.000Z","updated":"2020-07-27T23:34:03.259Z","comments":true,"path":"2020/07/27/虚拟机栈/","link":"","permalink":"http://tab-tan.github.io/2020/07/27/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/","excerpt":"","text":"调整虚拟机栈的大小的参数 -Xss 栈的结构栈有一个个栈帧组成|–栈|—-|–栈帧|—-|—-|–局部变量表|—-|—-|–操作数栈|—-|—-|–方法返回地址|—-|—-|–动态链接|—-|—-|–一些附加信息 如图： 局部变量表 也被称为局表变量数组或本地变量表，是一个数字数组。 记录基本数据类型和对象的引用和返回值类型。 局部变量表的大小在编译器就被确定不会改变。 基本存储单元：slot（变量槽） 32位以内的类型只占用一个槽，64位（long、double）占用两个槽 实例方法中局部变量表的首位存放this 注意solt重复利用的问题 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部 变量表中直接或间接引用的对象都不会被回收。 操作数栈 主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间 方法刚执行的时候，一个新的栈帧会被创建，这个方法的操作数栈是空的 如果调用的方法带有返回值，返回值会被压入当前栈帧的操作数栈 操作数栈有明确的长度，为方法的code属性中的max_stack的值 操作数栈并非采用索引的方式来进行数据访问 JVM的解释引擎是基于栈的执行引擎，其中的栈指的是操作数栈 动态链接（指向运行时常量池的方法引用） 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。 动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。 方法调用（提出去）方法返回地址 存储该方法PC寄存器的值 一个方法的结束有两种方式 正常执行结束 出现未处理异常，非正常退出 无论通过哪种方式退出，在方法退出后都会返回该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存着部分信息。 一些附加信息 栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如对程序调试提供支持的信息。 其中方法返回地址、动态链接、一些附加信息称为帧数据区","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/tags/JVM/"},{"name":"栈","slug":"栈","permalink":"http://tab-tan.github.io/tags/%E6%A0%88/"}]},{"title":"类加载器","slug":"类加载器","date":"2020-07-27T01:48:27.000Z","updated":"2020-07-27T02:37:25.275Z","comments":true,"path":"2020/07/27/类加载器/","link":"","permalink":"http://tab-tan.github.io/2020/07/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/","excerpt":"","text":"各层级类加载器的关系 ClassLoader的继承树 类加载器的分类虚拟机自带的加载器 启动类加载器（引导类加载器 Bootstrap ClassLoader） 使用c/c++实现的，嵌套在JVM内部 用来加载Java的核心库，用于提供JVM自身需要的类 并不继承自java.lang.ClassLoader，没有父加载器 加载扩展类和应用程序类加载器，并指定为他们的父类加载器 只加载包名为java、javax、sun等开头的类 扩展类加载器（Extension ClassLoader） Java编写，由sun.misc.Launcher$ExtClassLoader实现 派生于ClassLoader类 父类加载器为启动类加载器 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。 应用程序类加载器（系统类加载器 AppClassLoader） java编写，由sun.misc.Launcher$AppClassLoader实现 派生于ClassLoader类 父类加载器为扩展类加载器 负责加载环境变量classpath或系统属性java.class.path指定路径下的类库 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器 用户自定义类加载器 为什么要自定义类的加载器？ 隔离加载类 修改类加载方式 扩展加载源 防止源码泄漏 实现步骤 ClassLoader ClassLoader类，他是一个抽象类，其后所有的类加载器都继承自ClassLoader(不包括启动类加载器) 常用方法如下表: 方法 描述 getParent() 返回该类加载器的超类加载器 loadClass(String name) 加载名称为name的类，返回java.lang.Class类的实例 findClass(String name) 查找名为name的类，返回java.lang.Class类的实例 findLoadedClass(String name) 查找名为name的已经被加载过的类，返回结果为java.lang.Class类的实例 defineClass(String name,byte[] b,int off,int len) 把字节数组b中的内容转换为一个java类，返回结果为java.lang.Class类的实例 resolveClass(Class&lt;?&gt;c) 链接指定的一个java类","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/tags/JVM/"},{"name":"类加载器","slug":"类加载器","permalink":"http://tab-tan.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"}]},{"title":"双亲委派机制","slug":"双亲委派机制","date":"2020-07-27T01:13:20.000Z","updated":"2020-07-27T01:47:28.420Z","comments":true,"path":"2020/07/27/双亲委派机制/","link":"","permalink":"http://tab-tan.github.io/2020/07/27/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/","excerpt":"","text":"引入 Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。 双亲委派机制工作原理 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行 如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器 如果父类加载器可以完成加载任务，就成功返回，若不能完成则子加载器才会尝试自己加载 图示： 双亲委派机制优势 避免类的重复加载 保护程序安全，防止核心API被随意篡改 沙箱安全机制 在加载类的时候遇到用户自定义如java.lang包的类时，这个类会被委派到引导类加载器。引导类加载器会对此类进行校验，假如此类不是核心库中的类则会直接报错终止程序。这种安全校验就是沙箱安全机制，对jvm和程序起到了保护作用。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/tags/JVM/"},{"name":"机制","slug":"机制","permalink":"http://tab-tan.github.io/tags/%E6%9C%BA%E5%88%B6/"}]},{"title":"类的加载过程","slug":"类的加载过程","date":"2020-07-26T10:36:23.000Z","updated":"2020-07-26T23:24:36.983Z","comments":true,"path":"2020/07/26/类的加载过程/","link":"","permalink":"http://tab-tan.github.io/2020/07/26/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"","text":"类的加载过程类的加载有三大步 加载 链接 初始化 加载 通过类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 链接 验证(Verify) 目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。 准备(Prepare) 为类变量分配内存并且设置该变量的默认初始值，即零值。 这里不包括含用final修饰的static，因为final在编译的时候就会分配，准备阶段会显示初始化。 这里不会为实例变量分配初始化，变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。 解析(Resolve) 将常量池内的符号引用转换为直接引用的过程。 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。 初始化 初始化阶段就是执行类构造器方法()的过程。 此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 构造器方法中指令按语句在源文件中出现的顺序执行。 ()不同于类的构造器。(关联：构造器是虚拟机视角下的()) 若该类具有父类，JVM会保证子类的()执行前父类的()已经执行完毕。 虚拟机必须保证一个类的()方法在多线程下被同步加锁。 举例 初始化的最后一点意思是一个类只会被加载一次，我们来用代码对这句话进行验证。代码如下： 123456789101112131415161718192021222324252627public class DeadThread &#123; public static void main(String[] args) &#123; Runnable r = ()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\" 开始\"); new Dead(); System.out.println(Thread.currentThread().getName()+\" 结束\"); &#125;; new Thread(r,\"线程1\").start(); new Thread(r,\"线程2\").start(); &#125;&#125;class Dead&#123; static&#123; if (true)&#123; System.out.println(Thread.currentThread().getName()+\"正在进行初始化\"); while (true)&#123; &#125; &#125; &#125;&#125; 结果: 简单的说明一下，这里故意让Dead类无法正常的加载，然后起了两个线程去加载这个类。从结果来看线程2先来对Dead进行了加载，而在线程2没有加载完的情况下线程1没有去加载Dead类，验证了只会被加载一次。 理解类的加载得出答案 12345678910111213141516171819public class ClinitTest &#123; static class Father&#123; public static int A=1; static &#123; A=2; &#125; &#125; static class Sun extends Father&#123; public static int B=A; &#125; public static void main(String[] args) &#123; System.out.println(Sun.B); &#125;&#125; 结果: 说明在加载子类的时候会首先加载其父类，这里加载Sun的时候首先去加载了父类Father成员变量A的值由1变成2，当加载Sun时A的值为2，所以赋值给B，B的值为2","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/tags/JVM/"},{"name":"类的加载","slug":"类的加载","permalink":"http://tab-tan.github.io/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"}]},{"title":"多线程","slug":"多线程","date":"2020-07-25T13:09:08.000Z","updated":"2020-07-25T13:51:30.388Z","comments":true,"path":"2020/07/25/多线程/","link":"","permalink":"http://tab-tan.github.io/2020/07/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"多线程基础实现多线程的四种方式 继承Thread类 实现Runnable接口 实现Callable接口 使用线程池 常用方法 run(),start(),currentThread(),getName(),yield()(放弃cpu的当前执行权),wait(),notify()/notifyAll(),join()sleep(),isAlive(),stop()(已过时) 优先级 MAX_PRIORITY:10（Thread.MAX_PRIORITY）MIN_PRIORITY:1NORM_PRIORITY:5 线程的同步（线程的安全问题） 操作共享数据的代码，即为被同步的代码。 共享数据：多个线程抢夺的资源 同步监视器，俗称：锁。 Callable接口 实现类实现Callable接口 将实现类作为参数创建FutureTask 将FutureTask对象作为参数创建Thread并启动线程 代码： 1234567891011121314151617181920212223242526272829303132333435import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class CallableTest &#123; public static void main(String[] args) &#123; NumSum ns = new NumSum(); FutureTask f = new FutureTask(ns); new Thread(f).start(); Object object; try &#123; object = f.get(); System.out.println(object); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class NumSum implements Callable&#123; int sum = 0; @Override public Object call() throws Exception &#123; for(int i = 0 ; i&lt;50 ; i++) &#123; sum++; &#125; return sum; &#125;&#125; 结果： 线程池 JDK5.0提供线程池相关API：ExecutorService(接口)和Excutors(工具类) 常用方法： Executors.newFixedThreadPool(int i)创建固定数量的线程池。 excute()执行，无返回值 submit()执行，可以有返回值 shutdown()关闭线程池 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.FutureTask;public class ThreadPool &#123; public static void main(String[] args) &#123; MyTest myTest = new MyTest(); ExecutorService pool = Executors.newFixedThreadPool(10); pool.execute(new MyThread()); Future submit = pool.submit(myTest); Object object; try &#123; object = submit.get(); System.out.println(object); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; //关闭连接池 pool.isShutdown(); &#125;&#125;class MyTest implements Callable&#123; int m = 0; @Override public Object call() throws Exception &#123; for (int i = 0; i &lt; 50; i++) &#123; m++; &#125; return m; &#125; &#125;class MyThread implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(i); &#125; &#125; &#125; 结果： 设置线程池属性 corePoolSize:核心池大小maximumPoolSize:最大线程数keepAliveTime:无任务终止时间数","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"http://tab-tan.github.io/categories/Java-SE/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"多线程","slug":"多线程","permalink":"http://tab-tan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"搭建博客","slug":"搭建博客","date":"2020-07-25T11:40:38.000Z","updated":"2020-07-25T12:53:55.625Z","comments":true,"path":"2020/07/25/搭建博客/","link":"","permalink":"http://tab-tan.github.io/2020/07/25/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"环境github+hexo搭建个人博客 安装环境 安装nodejs 前往nodejs官网下载安装链接-http://nodejs.cn/download/ 安装hexo npm install -g hexo-cli(建议安装淘宝cnpm更快你懂的~) 创建博客文件夹 mkdir blog 如图: 初始化hexo 打开命令行进入创建好的blog命令行开始操作~hexo init 小操作 hexo n 博客标题:创建文章hexo clean | g(生成) | s(本地服务) 安装插件 npm install –save hexo-deployer-git 修改_config.yml文件 deploy:type: ‘git’repo: ‘https://github.com/Tab-Tan/Tab-tan.github.io.git&#39;branch: ‘master’ 远程部署 hexo d","categories":[{"name":"其他","slug":"其他","permalink":"http://tab-tan.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"搭建","slug":"搭建","permalink":"http://tab-tan.github.io/tags/%E6%90%AD%E5%BB%BA/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2020-07-24T11:09:03.000Z","updated":"2020-07-25T09:08:59.049Z","comments":true,"path":"2020/07/24/我的第一篇博客/","link":"","permalink":"http://tab-tan.github.io/2020/07/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"第一个博客也不知道说些什么 Java天下第一！ yeah~","categories":[{"name":"日常","slug":"日常","permalink":"http://tab-tan.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://tab-tan.github.io/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"hello-world","slug":"hello-world","date":"2020-07-24T10:01:59.985Z","updated":"2020-07-25T09:10:15.392Z","comments":true,"path":"2020/07/24/hello-world/","link":"","permalink":"http://tab-tan.github.io/2020/07/24/hello-world/","excerpt":"","text":"title: Hello WorldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/categories/JVM/"},{"name":"Java SE","slug":"Java-SE","permalink":"http://tab-tan.github.io/categories/Java-SE/"},{"name":"其他","slug":"其他","permalink":"http://tab-tan.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"日常","slug":"日常","permalink":"http://tab-tan.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/tags/JVM/"},{"name":"方法区","slug":"方法区","permalink":"http://tab-tan.github.io/tags/%E6%96%B9%E6%B3%95%E5%8C%BA/"},{"name":"堆","slug":"堆","permalink":"http://tab-tan.github.io/tags/%E5%A0%86/"},{"name":"栈","slug":"栈","permalink":"http://tab-tan.github.io/tags/%E6%A0%88/"},{"name":"类加载器","slug":"类加载器","permalink":"http://tab-tan.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"name":"机制","slug":"机制","permalink":"http://tab-tan.github.io/tags/%E6%9C%BA%E5%88%B6/"},{"name":"类的加载","slug":"类的加载","permalink":"http://tab-tan.github.io/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"},{"name":"多线程","slug":"多线程","permalink":"http://tab-tan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"搭建","slug":"搭建","permalink":"http://tab-tan.github.io/tags/%E6%90%AD%E5%BB%BA/"},{"name":"其他","slug":"其他","permalink":"http://tab-tan.github.io/tags/%E5%85%B6%E4%BB%96/"}]}