{"meta":{"title":"小谈同学","subtitle":"","description":"小谈同学的博客","author":"Tab tan","url":"http://tab-tan.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-07-25T09:21:18.000Z","updated":"2020-07-25T09:21:54.984Z","comments":true,"path":"categories/index.html","permalink":"http://tab-tan.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-07-25T09:22:18.000Z","updated":"2020-07-25T09:22:32.305Z","comments":true,"path":"tags/index.html","permalink":"http://tab-tan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"堆区","slug":"堆区","date":"2020-07-28T23:38:30.000Z","updated":"2020-07-29T00:19:08.732Z","comments":true,"path":"2020/07/29/堆区/","link":"","permalink":"http://tab-tan.github.io/2020/07/29/%E5%A0%86%E5%8C%BA/","excerpt":"","text":"堆的细分内存结构 现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为: Java 7及以前内存逻辑上分为三个部分：新生区+养老区+永久区 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Tenure generation Space 养老区 Old/Tenure Permanent Space 永久区 Perm Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Tenure generation Space 养老区 Old/Tenure Meta Space 元空间 Meta 约定：新生区=新生代=年轻代 | 养老区=老年区=老年代 | 永久区=永久代 堆空间大小的设置 Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。 “-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize “-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize 一旦堆区的内存大小超过”-Xmx”所指定的内存时，将会抛出OutOfMemoryError异常。 通常会将 -Xms和 -Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。 默认情况下，初始内存大小：物理电脑内存大小/64，最大内存大小：物理电脑内存大小/4 年轻代与老年代 配置新生代与老年代在堆结构的占比 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5 几乎所有的Java对象都是在Eden区被new出来的 绝大部分的Java对象的销毁都在新生代进行了 可以使用选项”-Xmn”设置新生代最大内存大小 这个参数一般使用默认值就可以了 对象的分配 对象分配总结: 针对幸存者s0，s1区：复制之后有交换，谁空谁是to 关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集 特殊情况 Minor GC Major GC Full GC JVM在进行GC时，并非每次都对上面三个内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大类型：一种是部分收集（Partial GC），一种是 整堆收集（Full GC） 部分收集 新生代收集(Minor GC/Young GC)：只是新生代(Eden,s0,s1)的垃圾收集 老年代收集(Major GC/Old GC)：只是老年代的垃圾收集 目前，只有CMS GC会有单独收集老年代的行为。 注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 目前只有G1 GC会有这种行为 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集 分代式GC策略的触发条件 年轻代GC(Minor GC)触发机制 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存） 因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度比较快。 Minor GC会引发STW，暂停其他用户线程，等垃圾回收结束，用户线程才恢复运行 老年代GC（Major GC/Full GC）触发机制 发生在老年代的GC，对象从老年代消失时，Major GC或Full GC发生了 出现了major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程） 也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足则会触发Major GC Major GC的速度一般比Minor GC慢10倍以上，STW的时间更长 如果Major GC后内存还不足则OOM（内存溢出） Full GC触发机制（提出去） 调用System.gc()时，系统建议执行Full GC，但是不必然执行 老年代空间不足 方法区空间不足 通过Minor GC后进入老年代的平均大小大于老年代的可用内存 由Eden区、survivor space0（From Space）区向survivor space1(To Space)区复制时，对象大小大于To Space可用内存，则把对象转存到老年代，且老年代的可用内存大小小于该对象大小 说明：Full GC是开发或调优中尽量要避免的。这样暂停时间会短一些。 对象分配过程：TLAB为什么有TLAB（Thread Local Allocation Buffer）? 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据 由于对象实例的创建在JVM中非常频繁，因为在并发环境下从堆区中划分内存空间是线程不安全的 为避免多个线程操作同一个地址，需要使用加锁等机制，进而影响分配速度。什么是TLAB？ 从内存模型而不是垃圾收集的角度，堆Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因为我们可以将这种内存分配方式称之为快速分配策略。 OpenJDK衍生出来的JVM都提供了TLAB的设计。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/tags/JVM/"},{"name":"堆","slug":"堆","permalink":"http://tab-tan.github.io/tags/%E5%A0%86/"}]},{"title":"方法引用","slug":"方法引用","date":"2020-07-27T23:36:04.000Z","updated":"2020-07-27T23:58:32.279Z","comments":true,"path":"2020/07/28/方法引用/","link":"","permalink":"http://tab-tan.github.io/2020/07/28/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/","excerpt":"","text":"引入：在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。 以下介绍关于方法引用的概念 方法的静态链接与动态链接 静态链接一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期间可知，且运行期间保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程叫做静态链接。 动态链接如果被调用的方法在编译期间无法确定，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称为动态链接。 早期绑定与晚期绑定 早期绑定被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。 晚期绑定如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。 非虚方法与虚方法 编译期就确定了具体的调用版本，这个版本在运行时是不可变的。 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。 其他的都是虚方法。 虚拟机中提供了以下几条方法调用指令 普通调用指令 invokestatic：调用静态方法，解析阶段确定唯一方法版本 invokespecial：调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本 invokevirtual：调用所有虚方法 invokeinterface：调用接口方法 动态调用指令 invokedynamic：动态解析出需要调用的方法，然后执行 前四条指令固化在虚拟机内部，方法的调用执行不可认为干预，而invokedynamic指令则支持用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的(final修饰的除外)称为虚方法。 虚方法表 虚方法表：为了提高性能，在类的加载中的解析的环节创建。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/tags/JVM/"},{"name":"栈","slug":"栈","permalink":"http://tab-tan.github.io/tags/%E6%A0%88/"}]},{"title":"虚拟机栈","slug":"虚拟机栈","date":"2020-07-27T14:50:12.000Z","updated":"2020-07-27T23:34:03.259Z","comments":true,"path":"2020/07/27/虚拟机栈/","link":"","permalink":"http://tab-tan.github.io/2020/07/27/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/","excerpt":"","text":"调整虚拟机栈的大小的参数 -Xss 栈的结构栈有一个个栈帧组成|–栈|—-|–栈帧|—-|—-|–局部变量表|—-|—-|–操作数栈|—-|—-|–方法返回地址|—-|—-|–动态链接|—-|—-|–一些附加信息 如图： 局部变量表 也被称为局表变量数组或本地变量表，是一个数字数组。 记录基本数据类型和对象的引用和返回值类型。 局部变量表的大小在编译器就被确定不会改变。 基本存储单元：slot（变量槽） 32位以内的类型只占用一个槽，64位（long、double）占用两个槽 实例方法中局部变量表的首位存放this 注意solt重复利用的问题 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部 变量表中直接或间接引用的对象都不会被回收。 操作数栈 主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间 方法刚执行的时候，一个新的栈帧会被创建，这个方法的操作数栈是空的 如果调用的方法带有返回值，返回值会被压入当前栈帧的操作数栈 操作数栈有明确的长度，为方法的code属性中的max_stack的值 操作数栈并非采用索引的方式来进行数据访问 JVM的解释引擎是基于栈的执行引擎，其中的栈指的是操作数栈 动态链接（指向运行时常量池的方法引用） 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。 动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。 方法调用（提出去）方法返回地址 存储该方法PC寄存器的值 一个方法的结束有两种方式 正常执行结束 出现未处理异常，非正常退出 无论通过哪种方式退出，在方法退出后都会返回该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存着部分信息。 一些附加信息 栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如对程序调试提供支持的信息。 其中方法返回地址、动态链接、一些附加信息称为帧数据区","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/tags/JVM/"},{"name":"栈","slug":"栈","permalink":"http://tab-tan.github.io/tags/%E6%A0%88/"}]},{"title":"类加载器","slug":"类加载器","date":"2020-07-27T01:48:27.000Z","updated":"2020-07-27T02:37:25.275Z","comments":true,"path":"2020/07/27/类加载器/","link":"","permalink":"http://tab-tan.github.io/2020/07/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/","excerpt":"","text":"各层级类加载器的关系 ClassLoader的继承树 类加载器的分类虚拟机自带的加载器 启动类加载器（引导类加载器 Bootstrap ClassLoader） 使用c/c++实现的，嵌套在JVM内部 用来加载Java的核心库，用于提供JVM自身需要的类 并不继承自java.lang.ClassLoader，没有父加载器 加载扩展类和应用程序类加载器，并指定为他们的父类加载器 只加载包名为java、javax、sun等开头的类 扩展类加载器（Extension ClassLoader） Java编写，由sun.misc.Launcher$ExtClassLoader实现 派生于ClassLoader类 父类加载器为启动类加载器 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。 应用程序类加载器（系统类加载器 AppClassLoader） java编写，由sun.misc.Launcher$AppClassLoader实现 派生于ClassLoader类 父类加载器为扩展类加载器 负责加载环境变量classpath或系统属性java.class.path指定路径下的类库 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器 用户自定义类加载器 为什么要自定义类的加载器？ 隔离加载类 修改类加载方式 扩展加载源 防止源码泄漏 实现步骤 ClassLoader ClassLoader类，他是一个抽象类，其后所有的类加载器都继承自ClassLoader(不包括启动类加载器) 常用方法如下表: 方法 描述 getParent() 返回该类加载器的超类加载器 loadClass(String name) 加载名称为name的类，返回java.lang.Class类的实例 findClass(String name) 查找名为name的类，返回java.lang.Class类的实例 findLoadedClass(String name) 查找名为name的已经被加载过的类，返回结果为java.lang.Class类的实例 defineClass(String name,byte[] b,int off,int len) 把字节数组b中的内容转换为一个java类，返回结果为java.lang.Class类的实例 resolveClass(Class&lt;?&gt;c) 链接指定的一个java类","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/tags/JVM/"},{"name":"类加载器","slug":"类加载器","permalink":"http://tab-tan.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"}]},{"title":"双亲委派机制","slug":"双亲委派机制","date":"2020-07-27T01:13:20.000Z","updated":"2020-07-27T01:47:28.420Z","comments":true,"path":"2020/07/27/双亲委派机制/","link":"","permalink":"http://tab-tan.github.io/2020/07/27/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/","excerpt":"","text":"引入 Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。 双亲委派机制工作原理 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行 如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器 如果父类加载器可以完成加载任务，就成功返回，若不能完成则子加载器才会尝试自己加载 图示： 双亲委派机制优势 避免类的重复加载 保护程序安全，防止核心API被随意篡改 沙箱安全机制 在加载类的时候遇到用户自定义如java.lang包的类时，这个类会被委派到引导类加载器。引导类加载器会对此类进行校验，假如此类不是核心库中的类则会直接报错终止程序。这种安全校验就是沙箱安全机制，对jvm和程序起到了保护作用。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/tags/JVM/"},{"name":"机制","slug":"机制","permalink":"http://tab-tan.github.io/tags/%E6%9C%BA%E5%88%B6/"}]},{"title":"类的加载过程","slug":"类的加载过程","date":"2020-07-26T10:36:23.000Z","updated":"2020-07-26T23:24:36.983Z","comments":true,"path":"2020/07/26/类的加载过程/","link":"","permalink":"http://tab-tan.github.io/2020/07/26/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"","text":"类的加载过程类的加载有三大步 加载 链接 初始化 加载 通过类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 链接 验证(Verify) 目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。 准备(Prepare) 为类变量分配内存并且设置该变量的默认初始值，即零值。 这里不包括含用final修饰的static，因为final在编译的时候就会分配，准备阶段会显示初始化。 这里不会为实例变量分配初始化，变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。 解析(Resolve) 将常量池内的符号引用转换为直接引用的过程。 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。 初始化 初始化阶段就是执行类构造器方法()的过程。 此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 构造器方法中指令按语句在源文件中出现的顺序执行。 ()不同于类的构造器。(关联：构造器是虚拟机视角下的()) 若该类具有父类，JVM会保证子类的()执行前父类的()已经执行完毕。 虚拟机必须保证一个类的()方法在多线程下被同步加锁。 举例 初始化的最后一点意思是一个类只会被加载一次，我们来用代码对这句话进行验证。代码如下： 123456789101112131415161718192021222324252627public class DeadThread &#123; public static void main(String[] args) &#123; Runnable r = ()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\" 开始\"); new Dead(); System.out.println(Thread.currentThread().getName()+\" 结束\"); &#125;; new Thread(r,\"线程1\").start(); new Thread(r,\"线程2\").start(); &#125;&#125;class Dead&#123; static&#123; if (true)&#123; System.out.println(Thread.currentThread().getName()+\"正在进行初始化\"); while (true)&#123; &#125; &#125; &#125;&#125; 结果: 简单的说明一下，这里故意让Dead类无法正常的加载，然后起了两个线程去加载这个类。从结果来看线程2先来对Dead进行了加载，而在线程2没有加载完的情况下线程1没有去加载Dead类，验证了只会被加载一次。 理解类的加载得出答案 12345678910111213141516171819public class ClinitTest &#123; static class Father&#123; public static int A=1; static &#123; A=2; &#125; &#125; static class Sun extends Father&#123; public static int B=A; &#125; public static void main(String[] args) &#123; System.out.println(Sun.B); &#125;&#125; 结果: 说明在加载子类的时候会首先加载其父类，这里加载Sun的时候首先去加载了父类Father成员变量A的值由1变成2，当加载Sun时A的值为2，所以赋值给B，B的值为2","categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/categories/JVM/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/tags/JVM/"},{"name":"类的加载","slug":"类的加载","permalink":"http://tab-tan.github.io/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"}]},{"title":"多线程","slug":"多线程","date":"2020-07-25T13:09:08.000Z","updated":"2020-07-25T13:51:30.388Z","comments":true,"path":"2020/07/25/多线程/","link":"","permalink":"http://tab-tan.github.io/2020/07/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"多线程基础实现多线程的四种方式 继承Thread类 实现Runnable接口 实现Callable接口 使用线程池 常用方法 run(),start(),currentThread(),getName(),yield()(放弃cpu的当前执行权),wait(),notify()/notifyAll(),join()sleep(),isAlive(),stop()(已过时) 优先级 MAX_PRIORITY:10（Thread.MAX_PRIORITY）MIN_PRIORITY:1NORM_PRIORITY:5 线程的同步（线程的安全问题） 操作共享数据的代码，即为被同步的代码。 共享数据：多个线程抢夺的资源 同步监视器，俗称：锁。 Callable接口 实现类实现Callable接口 将实现类作为参数创建FutureTask 将FutureTask对象作为参数创建Thread并启动线程 代码： 1234567891011121314151617181920212223242526272829303132333435import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class CallableTest &#123; public static void main(String[] args) &#123; NumSum ns = new NumSum(); FutureTask f = new FutureTask(ns); new Thread(f).start(); Object object; try &#123; object = f.get(); System.out.println(object); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class NumSum implements Callable&#123; int sum = 0; @Override public Object call() throws Exception &#123; for(int i = 0 ; i&lt;50 ; i++) &#123; sum++; &#125; return sum; &#125;&#125; 结果： 线程池 JDK5.0提供线程池相关API：ExecutorService(接口)和Excutors(工具类) 常用方法： Executors.newFixedThreadPool(int i)创建固定数量的线程池。 excute()执行，无返回值 submit()执行，可以有返回值 shutdown()关闭线程池 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.FutureTask;public class ThreadPool &#123; public static void main(String[] args) &#123; MyTest myTest = new MyTest(); ExecutorService pool = Executors.newFixedThreadPool(10); pool.execute(new MyThread()); Future submit = pool.submit(myTest); Object object; try &#123; object = submit.get(); System.out.println(object); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; //关闭连接池 pool.isShutdown(); &#125;&#125;class MyTest implements Callable&#123; int m = 0; @Override public Object call() throws Exception &#123; for (int i = 0; i &lt; 50; i++) &#123; m++; &#125; return m; &#125; &#125;class MyThread implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(i); &#125; &#125; &#125; 结果： 设置线程池属性 corePoolSize:核心池大小maximumPoolSize:最大线程数keepAliveTime:无任务终止时间数","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"http://tab-tan.github.io/categories/Java-SE/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"多线程","slug":"多线程","permalink":"http://tab-tan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"搭建博客","slug":"搭建博客","date":"2020-07-25T11:40:38.000Z","updated":"2020-07-25T12:53:55.625Z","comments":true,"path":"2020/07/25/搭建博客/","link":"","permalink":"http://tab-tan.github.io/2020/07/25/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"环境github+hexo搭建个人博客 安装环境 安装nodejs 前往nodejs官网下载安装链接-http://nodejs.cn/download/ 安装hexo npm install -g hexo-cli(建议安装淘宝cnpm更快你懂的~) 创建博客文件夹 mkdir blog 如图: 初始化hexo 打开命令行进入创建好的blog命令行开始操作~hexo init 小操作 hexo n 博客标题:创建文章hexo clean | g(生成) | s(本地服务) 安装插件 npm install –save hexo-deployer-git 修改_config.yml文件 deploy:type: ‘git’repo: ‘https://github.com/Tab-Tan/Tab-tan.github.io.git&#39;branch: ‘master’ 远程部署 hexo d","categories":[{"name":"其他","slug":"其他","permalink":"http://tab-tan.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"搭建","slug":"搭建","permalink":"http://tab-tan.github.io/tags/%E6%90%AD%E5%BB%BA/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2020-07-24T11:09:03.000Z","updated":"2020-07-25T09:08:59.049Z","comments":true,"path":"2020/07/24/我的第一篇博客/","link":"","permalink":"http://tab-tan.github.io/2020/07/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"第一个博客也不知道说些什么 Java天下第一！ yeah~","categories":[{"name":"日常","slug":"日常","permalink":"http://tab-tan.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://tab-tan.github.io/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"hello-world","slug":"hello-world","date":"2020-07-24T10:01:59.985Z","updated":"2020-07-25T09:10:15.392Z","comments":true,"path":"2020/07/24/hello-world/","link":"","permalink":"http://tab-tan.github.io/2020/07/24/hello-world/","excerpt":"","text":"title: Hello WorldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/categories/JVM/"},{"name":"Java SE","slug":"Java-SE","permalink":"http://tab-tan.github.io/categories/Java-SE/"},{"name":"其他","slug":"其他","permalink":"http://tab-tan.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"日常","slug":"日常","permalink":"http://tab-tan.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://tab-tan.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JVM","slug":"JVM","permalink":"http://tab-tan.github.io/tags/JVM/"},{"name":"堆","slug":"堆","permalink":"http://tab-tan.github.io/tags/%E5%A0%86/"},{"name":"栈","slug":"栈","permalink":"http://tab-tan.github.io/tags/%E6%A0%88/"},{"name":"类加载器","slug":"类加载器","permalink":"http://tab-tan.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"name":"机制","slug":"机制","permalink":"http://tab-tan.github.io/tags/%E6%9C%BA%E5%88%B6/"},{"name":"类的加载","slug":"类的加载","permalink":"http://tab-tan.github.io/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"},{"name":"多线程","slug":"多线程","permalink":"http://tab-tan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"搭建","slug":"搭建","permalink":"http://tab-tan.github.io/tags/%E6%90%AD%E5%BB%BA/"},{"name":"其他","slug":"其他","permalink":"http://tab-tan.github.io/tags/%E5%85%B6%E4%BB%96/"}]}