<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ElasticSearch+filebeat+logstash+kibana(版本7.14.0)</title>
      <link href="/2022/03/05/ElasticSearch-filebeat-logstash-kibana-%E7%89%88%E6%9C%AC7-14-0/"/>
      <url>/2022/03/05/ElasticSearch-filebeat-logstash-kibana-%E7%89%88%E6%9C%AC7-14-0/</url>
      
        <content type="html"><![CDATA[<h1 id="环境与前言"><a href="#环境与前言" class="headerlink" title="环境与前言"></a>环境与前言</h1><blockquote><p>centos7.x docker 20.x elk+filebeat 统一是7.14.0 本人大三，在一家小公司实习，最近公司里发版测试环境使用docker,觉得是时候学习一下docker了 于是学习了一下docker 不得不说上手之后很香。推荐到菜鸟教程学习，连接：<a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener" title="Docker教程">Docker教程</a>。学习完了部署了一下elk，也是在实习的时候接触到的，elk可以收集过滤分析日志，学习了一下。附上官网连接：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" target="_blank" rel="noopener" title="Elasticsearch: 权威指南">ElasticSearch: 权威指南</a> <a href="https://www.elastic.co/guide/en/logstash/current/index.html" target="_blank" rel="noopener" title="Logstash Reference">Logstash 文档</a> <a href="https://www.elastic.co/guide/en/kibana/current/index.html" target="_blank" rel="noopener" title="kibana 文档">Kibana 文档</a> <a href="https://www.elastic.co/guide/en/beats/filebeat/7.14/index.html" target="_blank" rel="noopener" title="Filebeat 文档">Filebeat 文档</a> 目前来说我只是单纯的使用，没有太过认真的去攻读这些文档，我只读了我用到的和一些配置的章节。以后有时间在慢慢学习下去吧，对这一块还算有点兴趣。</p></blockquote><h1 id="架构简介"><a href="#架构简介" class="headerlink" title="架构简介"></a>架构简介</h1><h2 id="简介与他们之间的联系"><a href="#简介与他们之间的联系" class="headerlink" title="简介与他们之间的联系"></a>简介与他们之间的联系</h2><ul><li><code>Elasticsearch</code> : 是一个分布式、<strong>RESTful</strong> 风格的<strong>搜索</strong>和<strong>数据分析</strong>引擎。</li><li><code>Logstash</code> : 是免费且开放的服务器端数据处理管道，能够从多个来源<strong>采集数据</strong>，<strong>转换数据</strong>，然后将数据<strong>发送</strong>到您最喜欢的“存储库”中。</li><li><code>Kibana</code> : 是一个免费且开放的用户界面，能够让您对 Elasticsearch 数据进行<strong>可视化</strong>，并让您在 Elastic Stack 中进行导航。您可以进行各种操作，从跟踪查询负载，到理解请求如何流经您的整个应用，都能轻松完成。 </li><li><code>Filebeat</code> : 无论是从安全设备、云、容器、主机还是 OT 进行<strong>数据收集</strong>，<code>Filebeat</code> 都将为您提供一种<strong>轻量型方法</strong>，用于转发和汇总日志与文件，让简单的事情不再繁杂。</li></ul><p>联系草图：</p><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-adf14dde1bd1606c759888d3449171bef43.png" alt=""></p><p>描述： 通过<code>filebeat</code>从文件控制台等日志源中收集日志，发送给<code>logstash</code>,<code>logstash</code>进行过滤存储到<code>elasticsearch</code>,<code>kibana</code>重<code>elasticsearch</code>中读取数据进行分析处理等。</p><blockquote><p>个人认为日志这东西是非常重要的，开发过程中程序跑不完善的日志可以快速排查定位错误原因。线上就更不用说了，没有错误日志咋死的都不知道。用过log4j的都说好，本次实验就使用log4j将日志输出到文本中。然后通过filebeat收集日志,再通过filebeat输出到logstash，logstash有过滤的能力,在通过logstash输出到elasticsearch进行存储，在通过Kibana查看分析什么的。废话讲完下面开始操作。</p></blockquote><h1 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h1><blockquote><p>说明也许多年后的你看到这篇文章这里的很多东西都已经过时了，但整个流程应该不会相差甚远，希望能帮你找到真个思路而不是ctrl cv。</p></blockquote><h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><blockquote><p>docker 中查找镜像 docker search [你想找地镜像]</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search elasticearch</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-c5a83b612a852a6c43433409f6d860afe6e.png" alt="&#39;控制台中搜索&#39;"></p><p>也可以去</p><p><a href="https://hub.docker.com" target="_blank" rel="noopener" title="Docker Hub">Docker Hub</a></p><p>搜索:</p><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-3b9b85a7dd6ba22f1cb387e0f0b637a7b09.png" alt="&#39;dockerhub中搜索&#39;"></p><p>点进去能看到版本号 我直接下载最新版7.14.0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticearch:7.14.0</span><br></pre></td></tr></table></figure><blockquote><p>access denied for elasticearch, repository does not exist or may require ‘docker login’: denied: requested access to the resource is denied 报这个错你就docker login登录 至于没有账号就去注册。下面的下载都是这样不在赘述。</p></blockquote><h2 id="filebeat"><a href="#filebeat" class="headerlink" title="filebeat"></a>filebeat</h2><p>拉取镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.elastic.co/beats/filebeat:7.14.0</span><br></pre></td></tr></table></figure><h2 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h2><p>拉取镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull logstash:7.14.0</span><br></pre></td></tr></table></figure><h2 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h2><p>拉取镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull kibana:7.14.0</span><br></pre></td></tr></table></figure><p>下载完成运行命令看一眼</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-9d89af7c621fb092c6715fc7068540bae26.png" alt=""></p><h1 id="配置运行"><a href="#配置运行" class="headerlink" title="配置运行"></a>配置运行</h1><h2 id="顺序说明"><a href="#顺序说明" class="headerlink" title="顺序说明"></a>顺序说明</h2><blockquote><p>说一下，按我的习惯是按照依赖的顺序来启动的。聪明的你想按照什么顺序都一样。</p></blockquote><h2 id="1-Elasticsearch"><a href="#1-Elasticsearch" class="headerlink" title="1 . Elasticsearch"></a>1 . Elasticsearch</h2><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9200:9200 -p 9300:9300 -e <span class="string">"discovery.type=single-node"</span> -d --net elk-net --name es elasticsearch:7.14.0</span><br></pre></td></tr></table></figure><blockquote><p>参数说明 : -p : 端口映射,将本机的9200映射到容器里的9200端口,访问localhost:9200就会访问到容器的9200. -e 环境变量 意思是将elasticsearch设置成单机运行 -d ： 后台运行,–net ：设置网络属于elk-net （你要是没有的话去简历或者不填这个配置）–name 设置容器的名字，不然的话默认一大串字母每次看日志还要ps一下多恶心你说是吧。</p></blockquote><h4 id="查看启动情况"><a href="#查看启动情况" class="headerlink" title="查看启动情况"></a>查看启动情况</h4><p>两种方式: </p><ol><li>docker ps -a</li></ol><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-620aff45f1dbd6f0c70ab14b2a1667dca9d.png" alt=""></p><blockquote><p>STATUS 顾名思义状态,是UP就ok，不是的话使用第二种方式看启动日志看看报的什么错然后去百度怎么解决。</p></blockquote><ol start="2"><li>docker logs -f es</li></ol><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-19f228522dd8dce7f3e16571c99d619cd4f.png" alt=""></p><blockquote><p>当然可以直接访问机器<code>ip:9200</code>查看有没有跑起来。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-746ffd0f4664469cad6c438a6c96f52da55.png" alt=""></p><p>到此为止用来存储的Elasticsearch启动完成丢在一边就完事了。值得一提的是，写这篇文章的时候，作者仅仅在摸鱼时（实习除了crud还是想弄一弄其他东西的，嘎嘎嘎）刚搭建完成最基本的elk，能跑，有许多配置包括安全什么的作者都没有去配置，这仅仅只是一篇没有营养的搭建教程。</p><h2 id="2-Kibana"><a href="#2-Kibana" class="headerlink" title="2 . Kibana"></a>2 . Kibana</h2><h4 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h4><p>在本地新建一个kibana的配置文件对应kibana中的<code>/config/kibana.yml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 递归创建文件夹</span><br><span class="line">mkdir -p /home/docker/elk/kibana</span><br><span class="line">// 创建编辑配置文件</span><br><span class="line">vi /home/docker/elk/kibana/kibana.yml</span><br></pre></td></tr></table></figure><p>这是<code>kibana.yml</code>内容:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.host:</span> <span class="string">"0"</span></span><br><span class="line"><span class="attr">server.shutdownTimeout:</span> <span class="string">"5s"</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> <span class="string">[</span> <span class="string">"http://你的ip:9200"</span> <span class="string">]</span></span><br><span class="line"><span class="attr">monitoring.ui.container.elasticsearch.enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>朋友，记得把‘’你的ip‘’换成你的机器ip</p></blockquote><h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /home/docker/elk/kibana:/config -p 5601:5601 -d --net elk-net --name kibana kibana:7.14.0</span><br></pre></td></tr></table></figure><p>参数解释:  ：<code>-v</code> : 挂载本地的文件夹到容器中config文件夹 <code>-p</code> ： 端口映射 <code>-d</code> :  后台运行 <code>--net</code> ：将容器加入指定网络 <code>--name</code> ： 给容器起个名字。</p><h4 id="查看启动效果"><a href="#查看启动效果" class="headerlink" title="查看启动效果"></a>查看启动效果</h4><ol><li>docker ps -a </li><li>docker logs -f kibana</li><li>浏览器访问 http://你的ip:5601<br>如果一切顺利你将看到如下画面:</li></ol><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-188207f5f0385890c68500507b0d3dc122c.png" alt=""></p><blockquote><p>小提示: 也许你在按照上面步骤ctrl cv之后并没有达到预期的效果,这是很正常的，生活总会事与愿违，你可能会看到页面一行没有准备好的英文,你在logs看到日志里有error告诉你elasticsearch节点信息查询不到等等等等。直接百度。作者也做过很多尝试,给你看看history，<img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-e15941fe01a15f54abbbb768fa3fa8e1dc5.png" alt="">最后在es节点自测没有问题的情况下，我给你提供一个最终的解决方案。进入容器，直接修改容器里的配置文件，保存退出后重启容器,命令如下：进入容器:<code>bash docker exec -it kibana /bin/bash</code>打开<code>/config/kibana.yml</code>配置文件：<code>bash vi /config/kibana.yml</code>如果你打开看到<code>elasticsearch.hosts: [ &quot;elasticsearch:9200&quot; ]</code>那说明问题就出现在这,这是默认的，你只需要把<code>elasticsearch</code>改成你自己的地址,保存退出<code>:wq</code>输入<code>exit</code>退出容器,输入<code>docker restart kibana</code>重启容器即可。</p></blockquote><p>至此elasticsearch和kibana启动完成。至于在kibana中操作查看es的内容自行百度，或者直接看官网也是可以的。<br>下面是<code>filebeat</code>和<code>logstash</code>的启动：</p><h2 id="3-Logstash"><a href="#3-Logstash" class="headerlink" title="3 . Logstash"></a>3 . Logstash</h2><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建配置文件的文件夹</span><br><span class="line">mkdir -p /home/docker/elk/logstash/</span><br><span class="line">// 创建并编辑配置文件</span><br><span class="line">vim /home/docker/elk/logstash/logstash.yml</span><br><span class="line">vim /home/docker/elk/logstash/logstash.conf</span><br></pre></td></tr></table></figure><p><code>logstash.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http.host:</span> <span class="string">"0.0.0.0"</span></span><br><span class="line"><span class="attr">xpack.monitoring.elasticsearch.hosts:</span> <span class="string">elasticsearch机器的ip:9200</span></span><br></pre></td></tr></table></figure><p><code>logstash.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port &#x3D;&gt; 4567</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  #Only matched data are send to output.</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts  &#x3D;&gt; [&quot;http:&#x2F;&#x2F;elasticsearch机器ip:9200&quot;]   #ElasticSearch host, can be array.</span><br><span class="line">    index  &#x3D;&gt; &quot;logapp-%&#123;+YYYY.MM&#125;&quot;         #The index to write data to.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 4567:4567 --net elk-net --name logstash -p 5044:5044 -p 5045:5045 -v /home/docker/elk/logstash/logstash.conf:/usr/share/logstash/pipeline/logstash.conf -v /home/docker/elk/logstash/logstash.yml:/usr/share/logstash/config/logstash.yml logstash:7.14.0</span><br></pre></td></tr></table></figure><blockquote><p>小提示：配置文件中分为三个模块，<code>input</code>,<code>filter</code>,<code>output</code>很好理解，就是把东西通过<code>input</code>输入，通过<code>filter</code>过滤，通过<code>output</code>输出。其中input中的<code>beats</code>插件就是我们下面要启动的<code>filebeat</code>。<code>filebeat</code>通过4567端口将收集的日志发送给<code>logstash</code>,当然想用哪个端口随便你。<br>启动完别忘了看看有没有启动成功,docker ps …,docker logs ….</p></blockquote><h2 id="4-Filebeat"><a href="#4-Filebeat" class="headerlink" title="4 . Filebeat"></a>4 . Filebeat</h2><h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><p>新建需要收集的日志文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /var/<span class="built_in">log</span>/logapp</span><br><span class="line">vim /var/<span class="built_in">log</span>/logapp/app.info.log</span><br></pre></td></tr></table></figure><p>然后在里面随便写点东西，我就写了一个test,真实环境中我们往往会收集nginx，java应用等的日志文件，这里我们就直接新建模拟一下了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/docker/elk/filebeat/</span><br><span class="line">vim /home/docker/elk/filebeat/filebeat.yml</span><br></pre></td></tr></table></figure><p><code>filebeat.yml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/<span class="built_in">log</span>/logapp/app.info.log</span><br><span class="line">output.logstash:</span><br><span class="line">    hosts: [<span class="string">"logstash的ip:4567"</span>]</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里把你的ip换上去，这就是前面<code>logstash</code>配置文件<code>input1</code>中<code>beats</code>监听的端口。<br>这里的缩进什么的都别丢了，严格按照<code>yaml</code>格式，不然就会报错。<code>input</code>中就是要收集的东西，我们收集一个刚刚我们新建的日志,<code>paths</code>里填上刚刚新建的日志文件的地址。</p></blockquote><h4 id="启动-3"><a href="#启动-3" class="headerlink" title="启动"></a>启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -u root -v /var/<span class="built_in">log</span>/logapp:/var/<span class="built_in">log</span>/logapp:rw -v /home/docker/elk/filebeat/filebeat.yml:/usr/share/filebeat/filebeat.yml:ro -e setup.kibana.host=你的kibana机器的ip:5601 -d --name filebeat --net elk-net docker.elastic.co/beats/filebeat:7.14.0</span><br></pre></td></tr></table></figure><blockquote><p>注意：记得把ip换成你的kibana的ip。<br>到此全部正常的话就算是整合完成了。让我们打开kibana操作一波看一下效果。</p></blockquote><h2 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h2><p>浏览器输入<a href="http://kibana的ip:5601进入kibana：">http://kibana的ip:5601进入kibana：</a></p><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-9e1705564e604aa91cd2b715b082ba8a71b.png" alt=""></p><p>选择管理：</p><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-7a909c1c30d828b3e41692f9a0ee2123c34.png" alt=""></p><p>选择索引配置：</p><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-f27bfe3b9e3c23168f655bd5011b536c661.png" alt=""></p><p>创建：</p><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-f050820e63b88ae72b9ce74d4d9a6cf198e.png" alt=""></p><p>输入之前配置文件中写的logapp下一步:</p><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-fe428bdec38f4ec39c4c50eb12bc07a5528.png" alt=""></p><p>选择时间戳创建：</p><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-8ef882457c790c3f0eeb6b470e1e65d67c3.png" alt=""></p><p>点击侧边栏，选择Discover：</p><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-0037cbf35ba4d867ce577a55739d74a884f.png" alt=""></p><p>选择刚刚创建的pattern：</p><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-27737eb23b6f3aa475761a068f184f3310e.png" alt=""></p><p>这一条数据就是创建文件是写的test：</p><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-f895011d10e07ff3b6862e77280ebf73be1.png" alt=""></p><p>这时去echo写入一条hello elk回到kibana查看:</p><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-60c4281debe2d46c1cb7bc8fdd3f874f1d9.png" alt=""><br><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-d865fb4bad3bdbec5871d285b810094bb23.png" alt=""></p><p>搜索一下：</p><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-9393ad172a5f21e47dfa54ad19460131ccf.png" alt=""></p><p>好了，至此elk的基础搭建就完成了。至少是跑起来了，至于想要实现些什么，就去配置文件里配置就行。</p>]]></content>
      
      
      <categories>
          
          <category> 环境/工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务调用之openFeign</title>
      <link href="/2021/01/17/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E4%B9%8BopenFeign/"/>
      <url>/2021/01/17/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E4%B9%8BopenFeign/</url>
      
        <content type="html"><![CDATA[<h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Feign 是一个声明式的Web服务客户端，让编写Web服务客户端变得非常容易，只需要创建一个接口并在接口上添加注解即可。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.16/pic/openFeign.png" alt="image-20201122150928756"></p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure><p><strong>主启动类添加注解<code>@EnableFeignClients</code></strong></p><p>service层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"CLOUD-PAYMENT-SERVICE"</span>)<span class="comment">// *注明要调用的微服务名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentFeignService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/payment/create"</span>) <span class="comment">// *要调用的地址</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Integer&gt; <span class="title">create</span><span class="params">(@RequestBody Payment payment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/payment/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">queryOne</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignController</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注入feign调用接口</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/customer/payment/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPaymentById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.queryOne(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h3><p>默认超时报错时间：<code>1s</code></p><p>application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置feign客户端超时时间（openFeign 默认支持 ribbon）</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="comment"># 指的是建立连接使用的时间，适用于网络状况正常的情况下，两端的连接所用时间</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="comment"># 指的是建立连接后从服务器读取到可用资源所用的时间</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><h3 id="日志增强"><a href="#日志增强" class="headerlink" title="日志增强"></a>日志增强</h3><h4 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h4><ul><li>NONE：磨人的，不显示任何日志；</li><li>BASIC：仅记录请求方法、URL、相应状态码及执行时间。</li><li>HEADERS：除了BASIC中定义的信息之外，还有请求和相应的头信息。</li><li>FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。</li></ul><p>FeignConfig.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment"># 哪个接口：什么级别</span></span><br><span class="line">    <span class="attr">com.tan.service.PaymentFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>基本使用<ul><li>主启动类加<code>@EnableFeignClients</code></li><li>Feign接口加<code>@FeignClient(value = &quot;服务名称&quot;)</code></li><li>Feign接口的方法头上加调用接口访问地址例如：<code>@GetMapping(&quot;/payment/get/{id}&quot;)</code></li></ul></li><li>超时控制<ul><li>默认使用ribbon<code>1s</code>超时</li><li>在配置文件中配置超时时间，参数：<code>ribbon.ReadTimeout</code>、<code>ribbon.ConnectTimeout</code></li></ul></li><li>日志增强<ul><li>配置类返回<code>Logger.Level</code></li><li>配置文件开启debug，例如：<code>logging.level.com.tan.service.PaymentFeignService=debug</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 服务调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2020/08/17/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/08/17/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><em>建造者模式也叫生成器模式。将一个复杂的对象构建与它的表示分离，使得同样的构建过程可以构建不同的表示。</em></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote><ul><li>封装性，使用建造者模式可以使客户端不必知道产品内部组成的细节。</li><li>建造者独立，容易扩展。</li><li>便于控制细节风险。由于具体的建造者是独立的，因此可以对建造者过程逐步细化，而不对其他模块产生任何影响。</li></ul></blockquote><h3 id="建造者模式实例"><a href="#建造者模式实例" class="headerlink" title="建造者模式实例"></a>建造者模式实例</h3><p>实例已上传至github，附上地址:<a href="https://github.com/Tab-Tan/design/tree/master/builder" target="_blank" rel="noopener">https://github.com/Tab-Tan/design/tree/master/builder</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/2020/08/17/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/08/17/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><em>为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。即工厂内造工厂。</em></p><h3 id="优点-amp-amp-缺点"><a href="#优点-amp-amp-缺点" class="headerlink" title="优点&amp;&amp;缺点"></a>优点&amp;&amp;缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><blockquote><ul><li>产品族内的约束为非公开状态，在不同的工厂中各种产品之间可能具有不同的相互依赖关系，这些依赖关系由工厂封装在其内部，对于工厂的使用者来说这些依赖是不可见的。</li><li>生产线的扩展非常容易。如果要针对同一产品族建立新的生产线，只需实现产品族中的所有产品接口并建立新的工厂类即可。</li></ul></blockquote><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><blockquote><p>产品族本身的扩展非常困难。如果产品族中增加一个新产品类型，则需要修改多个接口，并且会影响已有的工厂类。</p></blockquote><h3 id="抽象工厂实例"><a href="#抽象工厂实例" class="headerlink" title="抽象工厂实例"></a>抽象工厂实例</h3><p>实例已上传至github，附上地址:<a href="https://github.com/Tab-Tan/design/tree/master/factory/abstractFac" target="_blank" rel="noopener">https://github.com/Tab-Tan/design/tree/master/factory/abstractFac</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法区</title>
      <link href="/2020/07/29/%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
      <url>/2020/07/29/%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="方法区的基本理解"><a href="#方法区的基本理解" class="headerlink" title="方法区的基本理解"></a>方法区的基本理解</h3><blockquote><ul><li><strong>方法区(Method Area)与Java堆一样，是各个线程共享的内存区域。</strong></li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError:PermGen / Metaspace space <ul><li>举例：加载大量的第三方jar包；Tomcat部署的过程过多(30-50个)；大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul></blockquote><h3 id="Hotspot中方法区的演进"><a href="#Hotspot中方法区的演进" class="headerlink" title="Hotspot中方法区的演进"></a>Hotspot中方法区的演进</h3><blockquote><ul><li>jdk7及以前习惯把方法区称为永久代。jdk8使用元空间取代了永久代。</li><li>本质上，方法区和永久代并不等价。永久代仅是对hotspot而言。java虚拟机规范对如何实现方法区不作统一要求。<ul><li>现在看来，当年使用永久代导致Java程序更容易OOM（超过-XX:MaxPermSize上限）</li></ul></li><li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存。</strong></li><li>永久代、元空间并不只是名字变了，内部结构也调整了。</li><li>java虚拟机规范规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。</li></ul></blockquote><h3 id="设置方法区大小"><a href="#设置方法区大小" class="headerlink" title="设置方法区大小"></a>设置方法区大小</h3><blockquote><ul><li>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</li></ul></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.11/pic/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%BE1.png" alt="jdk7"><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.11/pic/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%BE2.png" alt="jdk8"></p><h3 id="方法区-Method-Area-存储什么？"><a href="#方法区-Method-Area-存储什么？" class="headerlink" title="方法区(Method Area)存储什么？"></a>方法区(Method Area)存储什么？</h3><blockquote><p>用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码缓存等。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.11/pic/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%BE3.png" alt="方法区"></p><h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><blockquote><p>对每个加载的类型(类class、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下类型信息：</p><ul><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）</li><li>这个类型的修饰符(public , abstract , final的某个子集)</li><li>这个类型直接接口的一个有序列表</li></ul></blockquote><h4 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h4><blockquote><ul><li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</li><li>域的相关信息包括：域名称、域类型、域修饰符(public,private,protected,static,final,volatile,transient的某个子集)</li></ul></blockquote><h4 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h4><blockquote><ul><li>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</li><li>方法名称</li><li>方法的返回类型(或 void)</li><li>方法参数的数量和类型(按顺序)</li><li>方法的修饰符(public,private,protected,static,final,synchronized,native,abstract的一个子集)</li><li>方法的字节码(bytecodes)、操作数栈、局部变量表及大小(abstract和native方法除外)</li><li>异常表（abstract和native除外）<ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ul></blockquote><h4 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h4><blockquote><ul><li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分。</li><li>类变量被类的所有实例共享，即使没有类实例时你也可以访问它。</li></ul></blockquote><h4 id="常量池中有什么？"><a href="#常量池中有什么？" class="headerlink" title="常量池中有什么？"></a>常量池中有什么？</h4><blockquote><p>一个有效的字节码文件中除了包含版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表(Constant Pool Table)，包括各种字面量和对类型、域和方法的符号引用。</p><ul><li>数值量</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用<br>小结：常量池可以看做一张表，虚拟机指令根据这张表找到要执行的类名、方法名、参数类型、字面量等类型。</li></ul></blockquote><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><blockquote><ul><li>方法区的一部分</li><li>常量池表是Class文件的一部分，<strong>用于存放编译期产生的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池</strong>。   </li><li>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组一样，是通过<strong>索引访问</strong>的。</li><li>运行时常量池中包含多种不同的常量，包含编译期就确定的数值字面量，也包括到运行期解析后才能获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里<strong>换为真实地址</strong>。<ul><li>运行时常量池相对于Class文件常量池的另一个重要特征：<strong>具备动态性</strong></li></ul></li><li>运行时常量池类似于穿统编程语言中的符号表(symbol table)，但是它所包含的数据却比符号表要更加丰富一些。</li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的的最大值，则JVM会抛OutOfMemoryError异常。</li></ul></blockquote><h3 id="方法区的演进细节-Hotspot"><a href="#方法区的演进细节-Hotspot" class="headerlink" title="方法区的演进细节(Hotspot)"></a>方法区的演进细节(Hotspot)</h3><blockquote><ol><li>首先明确，只有hotspot才有永久代。</li><li>hotspot中方法区的变化如下表：</li></ol><table><thead><tr><th align="center">版本</th><th align="center">变化</th></tr></thead><tbody><tr><td align="center">jdk6及之前</td><td align="center">有永久代(Permanent generation)，静态变量存放在永久代上</td></tr><tr><td align="center">jdk7</td><td align="center">有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中</td></tr><tr><td align="center">jdk8及之后</td><td align="center">无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池，静态变量仍在堆</td></tr></tbody></table></blockquote><p>图示：<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.11/pic/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%BE4.png" alt="方法区"><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.11/pic/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%BE5.png" alt="方法区"><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.11/pic/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%BE6.png" alt="方法区"></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="永久代为什么要被元空间替换？"><a href="#永久代为什么要被元空间替换？" class="headerlink" title="永久代为什么要被元空间替换？"></a>永久代为什么要被元空间替换？</h4><blockquote><ul><li>给永久代设置空间大小是很难确定的。</li><li>对永久代进行调优是很困难的。</li></ul></blockquote><h4 id="StringTable为什么要调整？"><a href="#StringTable为什么要调整？" class="headerlink" title="StringTable为什么要调整？"></a>StringTable为什么要调整？</h4><blockquote><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。这就导致StringTable回收效率不高。而开发中大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆中，能及时回收内存。</p></blockquote><h3 id="方法区的垃圾收集"><a href="#方法区的垃圾收集" class="headerlink" title="方法区的垃圾收集"></a>方法区的垃圾收集</h3><blockquote><ul><li>方法区内常量池中主要存放两大类常量：字面量和符号引用。</li><li>hotspot只要常量池中的常量没有被任何地方引用，就可以被回收。</li><li>回收废弃常量会回收Java堆中的对象非常类似.</li><li>判断类可回收的三个条件<ul><li>该类的所有实例都已被回收,Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的加载器已被回收,这个条件除非是经过精心设计的可替换加载器的场景,否则很难达成。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类方法。</li></ul></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 基础 </tag>
            
            <tag> 方法区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆区</title>
      <link href="/2020/07/29/%E5%A0%86%E5%8C%BA/"/>
      <url>/2020/07/29/%E5%A0%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="堆的细分内存结构"><a href="#堆的细分内存结构" class="headerlink" title="堆的细分内存结构"></a>堆的细分内存结构</h3><blockquote><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为:</p><ul><li>Java 7及以前内存逻辑上分为三个部分：新生区+养老区+永久区<ul><li>Young Generation Space    新生区    Young/New<ul><li>又被划分为Eden区和Survivor区</li></ul></li><li>Tenure generation Space    养老区    Old/Tenure</li><li>Permanent Space                永久区    Perm</li></ul></li><li>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间<ul><li>Young Generation Space    新生区    Young/New<ul><li>又被划分为Eden区和Survivor区</li></ul></li><li>Tenure generation Space    养老区    Old/Tenure</li><li>Meta Space                          元空间    Meta</li></ul></li></ul><p><em>约定：新生区=新生代=年轻代 | 养老区=老年区=老年代 | 永久区=永久代</em></p></blockquote><h3 id="堆空间大小的设置"><a href="#堆空间大小的设置" class="headerlink" title="堆空间大小的设置"></a>堆空间大小的设置</h3><blockquote><ul><li>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。<ul><li>“-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize</li><li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li></ul></li><li>一旦堆区的内存大小超过”-Xmx”所指定的内存时，将会抛出OutOfMemoryError异常。</li><li>通常会将 -Xms和 -Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</li><li>默认情况下，初始内存大小：物理电脑内存大小/64，最大内存大小：物理电脑内存大小/4</li></ul></blockquote><h3 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h3><blockquote><p>配置新生代与老年代在堆结构的占比</p><ul><li>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.9/pic/%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3.png" alt="年轻代与老年代"></li><li>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</li><li>几乎所有的Java对象都是在Eden区被new出来的</li><li>绝大部分的Java对象的销毁都在新生代进行了</li><li>可以使用选项”-Xmn”设置新生代最大内存大小<ul><li>这个参数一般使用默认值就可以了</li></ul></li></ul></blockquote><h3 id="对象的分配"><a href="#对象的分配" class="headerlink" title="对象的分配"></a>对象的分配</h3><blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.9/pic/%E5%AF%B9%E8%B1%A1%E6%99%8B%E5%8D%87.png" alt="对象晋升"><br>对象分配总结:</p><ul><li><strong>针对幸存者s0，s1区：复制之后有交换，谁空谁是to</strong></li><li><strong>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集</strong></li></ul></blockquote><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.9/pic/%E5%A0%86%E5%86%85%E6%99%8B%E5%8D%87%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="对象晋升流程图"></p><h3 id="Minor-GC-Major-GC-Full-GC"><a href="#Minor-GC-Major-GC-Full-GC" class="headerlink" title="Minor GC Major GC Full GC"></a>Minor GC Major GC Full GC</h3><blockquote><p>JVM在进行GC时，并非每次都对上面三个内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。<br>针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大类型：一种是部分收集（Partial GC），一种是 整堆收集（Full GC）</p><ul><li>部分收集<ul><li>新生代收集(Minor GC/Young GC)：只是新生代(Eden,s0,s1)的垃圾收集</li><li>老年代收集(Major GC/Old GC)：只是老年代的垃圾收集<ul><li>目前，只有CMS GC会有单独收集老年代的行为。</li><li><strong>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</strong></li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集<ul><li>目前只有G1 GC会有这种行为</li></ul></li></ul></li><li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集</li></ul></blockquote><h3 id="分代式GC策略的触发条件"><a href="#分代式GC策略的触发条件" class="headerlink" title="分代式GC策略的触发条件"></a>分代式GC策略的触发条件</h3><blockquote><ul><li>年轻代GC(Minor GC)触发机制<ul><li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存）</li><li>因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度比较快。</li><li>Minor GC会引发STW，暂停其他用户线程，等垃圾回收结束，用户线程才恢复运行</li></ul></li><li>老年代GC（Major GC/Full GC）触发机制<ul><li>发生在老年代的GC，对象从老年代消失时，Major GC或Full GC发生了</li><li>出现了major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）<ul><li>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足则会触发Major GC</li></ul></li><li>Major GC的速度一般比Minor GC慢10倍以上，STW的时间更长</li><li>如果Major GC后内存还不足则OOM（内存溢出）</li></ul></li><li>Full GC触发机制（提出去）<ul><li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor space0（From Space）区向survivor space1(To Space)区复制时，对象大小大于To Space可用内存，则把对象转存到老年代，且老年代的可用内存大小小于该对象大小<ul><li>说明：Full GC是开发或调优中尽量要避免的。这样暂停时间会短一些。</li></ul></li></ul></li></ul></blockquote><h3 id="对象分配过程：TLAB"><a href="#对象分配过程：TLAB" class="headerlink" title="对象分配过程：TLAB"></a>对象分配过程：TLAB</h3><h4 id="为什么有TLAB（Thread-Local-Allocation-Buffer）"><a href="#为什么有TLAB（Thread-Local-Allocation-Buffer）" class="headerlink" title="为什么有TLAB（Thread Local Allocation Buffer）?"></a>为什么有TLAB（Thread Local Allocation Buffer）?</h4><blockquote><ul><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在JVM中非常频繁，因为在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一个地址，需要使用加锁等机制，进而影响分配速度。<br>什么是TLAB？</li><li>从内存模型而不是垃圾收集的角度，堆Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</li><li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因为我们可以将这种内存分配方式称之为快速分配策略。</li><li>OpenJDK衍生出来的JVM都提供了TLAB的设计。</li></ul></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.10/pic/TLAB%E8%AF%B4%E6%98%8E.png" alt="TLAB说明"></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.10/pic/TLAB.png" alt="TLAB说明"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 基础 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法引用</title>
      <link href="/2020/07/28/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
      <url>/2020/07/28/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><em>引入：在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。</em></p><p>以下介绍关于方法引用的概念</p><hr><h3 id="方法的静态链接与动态链接"><a href="#方法的静态链接与动态链接" class="headerlink" title="方法的静态链接与动态链接"></a>方法的静态链接与动态链接</h3><blockquote><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期间可知，且运行期间保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程叫做静态链接。</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>如果被调用的方法在编译期间无法确定，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称为动态链接。</p></blockquote><h3 id="早期绑定与晚期绑定"><a href="#早期绑定与晚期绑定" class="headerlink" title="早期绑定与晚期绑定"></a>早期绑定与晚期绑定</h3><blockquote><h4 id="早期绑定"><a href="#早期绑定" class="headerlink" title="早期绑定"></a>早期绑定</h4><p>被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p><h4 id="晚期绑定"><a href="#晚期绑定" class="headerlink" title="晚期绑定"></a>晚期绑定</h4><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p></blockquote><h3 id="非虚方法与虚方法"><a href="#非虚方法与虚方法" class="headerlink" title="非虚方法与虚方法"></a>非虚方法与虚方法</h3><blockquote><ul><li>编译期就确定了具体的调用版本，这个版本在运行时是不可变的。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他的都是虚方法。</li></ul></blockquote><h3 id="虚拟机中提供了以下几条方法调用指令"><a href="#虚拟机中提供了以下几条方法调用指令" class="headerlink" title="虚拟机中提供了以下几条方法调用指令"></a>虚拟机中提供了以下几条方法调用指令</h3><blockquote><h4 id="普通调用指令"><a href="#普通调用指令" class="headerlink" title="普通调用指令"></a>普通调用指令</h4><ol><li><strong>invokestatic</strong>：调用静态方法，解析阶段确定唯一方法版本</li><li><strong>invokespecial</strong>：调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本</li><li><strong>invokevirtual</strong>：调用所有虚方法</li><li><strong>invokeinterface</strong>：调用接口方法</li></ol></blockquote><blockquote><h4 id="动态调用指令"><a href="#动态调用指令" class="headerlink" title="动态调用指令"></a>动态调用指令</h4><ol start="5"><li><strong>invokedynamic</strong>：动态解析出需要调用的方法，然后执行</li></ol><p><em>前四条指令固化在虚拟机内部，方法的调用执行不可认为干预，而invokedynamic指令则支持用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的(final修饰的除外)称为虚方法。</em></p></blockquote><h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><blockquote><p>虚方法表：为了提高性能，在类的加载中的解析的环节创建。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 基础 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机栈</title>
      <link href="/2020/07/27/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
      <url>/2020/07/27/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<blockquote><pre><code>调整虚拟机栈的大小的参数 -Xss    </code></pre></blockquote><hr><h3 id="栈的结构"><a href="#栈的结构" class="headerlink" title="栈的结构"></a>栈的结构</h3><p><em>栈有一个个栈帧组成</em><br>|–栈<br>|—-|–栈帧<br>|—-|—-|–<strong>局部变量表</strong><br>|—-|—-|–<strong>操作数栈</strong><br>|—-|—-|–方法返回地址<br>|—-|—-|–动态链接<br>|—-|—-|–一些附加信息</p><p>如图：<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.7/pic/zz.png" alt="结构"></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><blockquote><ol><li>也被称为局表变量数组或本地变量表，是一个数字数组。</li><li>记录基本数据类型和对象的引用和返回值类型。</li><li>局部变量表的大小在编译器就被确定不会改变。</li><li>基本存储单元：slot（变量槽）</li><li>32位以内的类型只占用一个槽，64位（long、double）占用两个槽</li><li>实例方法中局部变量表的首位存放this</li><li>注意solt重复利用的问题</li><li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部</li><li><strong>变量表中直接或间接引用的对象都不会被回收。</strong></li></ol></blockquote><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><blockquote><ol><li><strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></li><li>方法刚执行的时候，一个新的栈帧会被创建，<strong>这个方法的操作数栈是空的</strong></li><li><strong>如果调用的方法带有返回值，返回值会被压入当前栈帧的操作数栈</strong></li><li>操作数栈有明确的长度，为方法的code属性中的max_stack的值</li><li>操作数栈<strong>并非采用索引的方式来进行数据访问</strong></li><li>JVM的<strong>解释引擎是基于栈的执行引擎</strong>，其中的栈指的是操作数栈</li></ol></blockquote><h3 id="动态链接（指向运行时常量池的方法引用）"><a href="#动态链接（指向运行时常量池的方法引用）" class="headerlink" title="动态链接（指向运行时常量池的方法引用）"></a>动态链接（指向运行时常量池的方法引用）</h3><blockquote><ol><li>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。</li><li>在Java源文件被编译到字节码文件中时，<strong>所有的变量和方法引用都作为符号引用保存在class文件的常量池里</strong>。</li><li><strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong>。</li></ol></blockquote><h3 id="方法调用（提出去）"><a href="#方法调用（提出去）" class="headerlink" title="方法调用（提出去）"></a>方法调用（提出去）</h3><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><blockquote><ul><li>存储该方法PC寄存器的值</li><li>一个方法的结束有两种方式<ul><li>正常执行结束</li><li>出现未处理异常，非正常退出</li></ul></li><li>无论通过哪种方式退出，在方法退出后都会返回该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存着部分信息。</li></ul></blockquote><h3 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h3><blockquote><ul><li>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如对程序调试提供支持的信息。</li><li>其中方法返回地址、动态链接、一些附加信息称为帧数据区</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 基础 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器</title>
      <link href="/2020/07/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2020/07/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="各层级类加载器的关系"><a href="#各层级类加载器的关系" class="headerlink" title="各层级类加载器的关系"></a>各层级类加载器的关系</h3><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.6/pic/clgx.png" alt="类加载器" title="类加载器"></p><h4 id="ClassLoader的继承树"><a href="#ClassLoader的继承树" class="headerlink" title="ClassLoader的继承树"></a>ClassLoader的继承树</h4><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.6/pic/ClassLoader.png" alt=""></p><h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><h4 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h4><blockquote><ul><li>启动类加载器（引导类加载器  Bootstrap ClassLoader）<ul><li>使用c/c++实现的，嵌套在JVM内部</li><li>用来加载Java的核心库，用于提供JVM自身需要的类</li><li>并不继承自java.lang.ClassLoader，没有父加载器</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</li><li>只加载包名为java、javax、sun等开头的类</li></ul></li><li>扩展类加载器（Extension ClassLoader）<ul><li>Java编写，由sun.misc.Launcher$ExtClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul></li><li>应用程序类加载器（系统类加载器 AppClassLoader）<ul><li>java编写，由sun.misc.Launcher$AppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器</li></ul></li><li>用户自定义类加载器<ul><li>为什么要自定义类的加载器？<ul><li>隔离加载类</li><li>修改类加载方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul></li><li>实现步骤<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.6/pic/zdycl.png" alt=""></li></ul></li></ul></blockquote><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><blockquote><p>ClassLoader类，他是一个抽象类，其后所有的类加载器都继承自ClassLoader(不包括启动类加载器) 常用方法如下表:</p></blockquote><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">getParent()</td><td align="center">返回该类加载器的超类加载器</td></tr><tr><td align="center">loadClass(String name)</td><td align="center">加载名称为name的类，返回java.lang.Class类的实例</td></tr><tr><td align="center">findClass(String name)</td><td align="center">查找名为name的类，返回java.lang.Class类的实例</td></tr><tr><td align="center">findLoadedClass(String name)</td><td align="center">查找名为name的已经被加载过的类，返回结果为java.lang.Class类的实例</td></tr><tr><td align="center">defineClass(String name,byte[] b,int off,int len)</td><td align="center">把字节数组b中的内容转换为一个java类，返回结果为java.lang.Class类的实例</td></tr><tr><td align="center">resolveClass(Class&lt;?&gt;c)</td><td align="center">链接指定的一个java类</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 基础 </tag>
            
            <tag> 类加载器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双亲委派机制</title>
      <link href="/2020/07/27/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/07/27/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><blockquote><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class时，Java虚拟机采用的是<strong>双亲委派模式</strong>，即把请求交由父类处理，它是一种任务委派模式。</p></blockquote><h3 id="双亲委派机制工作原理"><a href="#双亲委派机制工作原理" class="headerlink" title="双亲委派机制工作原理"></a>双亲委派机制工作原理</h3><blockquote><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li><li>如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器</li><li>如果父类加载器可以完成加载任务，就成功返回，若不能完成则子加载器才会尝试自己加载</li></ol></blockquote><p>图示：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.5/pic/clipboard.png" alt="双亲委派机制" title="双亲委派机制"></p><h3 id="双亲委派机制优势"><a href="#双亲委派机制优势" class="headerlink" title="双亲委派机制优势"></a>双亲委派机制优势</h3><blockquote><ol><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改</li></ol></blockquote><h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><blockquote><p>在加载类的时候遇到用户自定义如java.lang包的类时，这个类会被委派到引导类加载器。引导类加载器会对此类进行校验，假如此类不是核心库中的类则会直接报错终止程序。这种安全校验就是沙箱安全机制，对jvm和程序起到了保护作用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 机制 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的加载过程</title>
      <link href="/2020/07/26/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/07/26/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p>类的加载有三大步 <strong>加载</strong> <strong>链接</strong> <strong>初始化</strong><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.4/pic/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD.png" alt=""></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><blockquote><ul><li>通过类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ul></blockquote><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><blockquote><ul><li>验证(Verify)<ul><li>目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li><li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ul></li><li>准备(Prepare)<ul><li>为类变量分配内存并且设置该变量的默认初始值，即零值。</li><li>这里不包括含用final修饰的static，因为final在编译的时候就会分配，准备阶段会显示初始化。</li><li>这里不会为实例变量分配初始化，变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li></ul></li><li>解析(Resolve)<ul><li>将常量池内的符号引用转换为直接引用的过程。</li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</li></ul></li></ul></blockquote><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><blockquote><ul><li>初始化阶段就是执行类构造器方法<clinit>()的过程。</li><li>此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</li><li>构造器方法中指令按语句在源文件中出现的顺序执行。</li><li><clinit>()不同于类的构造器。(关联：构造器是虚拟机视角下的<clinit>())</li><li>若该类具有父类，JVM会保证子类的<clinit>()执行前父类的<clinit>()已经执行完毕。</li><li>虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁。</li></ul></blockquote><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ol><li>初始化的最后一点意思是<strong>一个类只会被加载一次</strong>，我们来用代码对这句话进行验证。代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = ()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" 开始"</span>);</span><br><span class="line">            <span class="keyword">new</span> Dead();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" 结束"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"线程1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"线程2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dead</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"正在进行初始化"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.4/pic/deadthread.png" alt=""></p><p>简单的说明一下，这里故意让Dead类无法正常的加载，然后起了两个线程去加载这个类。从结果来看线程2先来对Dead进行了加载，而在线程2没有加载完的情况下线程1没有去加载Dead类，验证了只会被加载一次。</p><ol start="2"><li>理解类的加载得出答案</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            A=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sun</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B=A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Sun.B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.4/pic/clinit.png" alt=""></p><p>说明在加载子类的时候会首先加载其父类，这里加载Sun的时候首先去加载了父类Father成员变量A的值由1变成2，当加载Sun时A的值为2，所以赋值给B，B的值为2</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 基础 </tag>
            
            <tag> 类的加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2020/07/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/07/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h2><h3 id="实现多线程的四种方式"><a href="#实现多线程的四种方式" class="headerlink" title="实现多线程的四种方式"></a>实现多线程的四种方式</h3><ol><li>继承Thread类</li><li>实现Runnable接口</li><li>实现Callable接口</li><li>使用线程池</li></ol><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><blockquote><p>run(),start(),currentThread(),getName(),<br>yield()(放弃cpu的当前执行权),<br>wait(),notify()/notifyAll(),join()<br>sleep(),isAlive(),stop()(已过时)</p></blockquote><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><blockquote><p>MAX_PRIORITY:10（Thread.MAX_PRIORITY）<br>MIN_PRIORITY:1<br>NORM_PRIORITY:5</p></blockquote><h3 id="线程的同步（线程的安全问题）"><a href="#线程的同步（线程的安全问题）" class="headerlink" title="线程的同步（线程的安全问题）"></a>线程的同步（线程的安全问题）</h3><ol><li>操作共享数据的代码，即为被同步的代码。</li><li>共享数据：多个线程抢夺的资源</li><li>同步监视器，俗称：锁。</li></ol><h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><ol><li><p>实现类实现Callable接口</p></li><li><p>将实现类作为参数创建FutureTask</p></li><li><p>将FutureTask对象作为参数创建Thread并启动线程</p><p> 代码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">NumSum ns = <span class="keyword">new</span> NumSum();</span><br><span class="line">FutureTask f = <span class="keyword">new</span> FutureTask(ns);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(f).start();</span><br><span class="line">Object object;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">object = f.get();</span><br><span class="line">System.out.println(object);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumSum</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">50</span> ; i++) &#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 结果：<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.3/pic/callable.png" alt="callable接口"></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3></li><li><p><strong>JDK5.0提供线程池相关API</strong>：ExecutorService(接口)和Excutors(工具类)</p></li><li><p><strong>常用方法</strong>：</p><ul><li><p>Executors.newFixedThreadPool(int i)创建固定数量的线程池。</p></li><li><p>excute()执行，无返回值</p></li><li><p>submit()执行，可以有返回值</p></li><li><p>shutdown()关闭线程池</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyTest myTest = <span class="keyword">new</span> MyTest();</span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">pool.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">Future submit = pool.submit(myTest);</span><br><span class="line">Object object;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">object = submit.get();</span><br><span class="line">System.out.println(object);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭连接池</span></span><br><span class="line">pool.isShutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">m++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1.3/pic/threadPool.png" alt="线程池" title="线程池"></p></li></ul></li></ol><h3 id="设置线程池属性"><a href="#设置线程池属性" class="headerlink" title="设置线程池属性"></a>设置线程池属性</h3><blockquote><p>corePoolSize:核心池大小<br>maximumPoolSize:最大线程数<br>keepAliveTime:无任务终止时间数</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客</title>
      <link href="/2020/07/25/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/07/25/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="github-hexo搭建个人博客"><a href="#github-hexo搭建个人博客" class="headerlink" title="github+hexo搭建个人博客"></a>github+hexo搭建个人博客</h3><hr><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><ol><li>安装nodejs<blockquote><p>前往nodejs官网下载安装<br>链接-<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a></p></blockquote></li><li>安装hexo<blockquote><p>npm install -g hexo-cli(建议安装淘宝cnpm更快你懂的~)</p></blockquote></li><li>创建博客文件夹<blockquote><p>mkdir blog</p></blockquote></li></ol><p>如图:<br> <img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Tab-tan/CDN@1.1/pic/dir.png" alt="创建文件夹"></p><ol start="4"><li><p>初始化hexo</p><blockquote><p>打开命令行进入创建好的blog命令行开始操作~<br>hexo init</p></blockquote></li><li><p>小操作</p><blockquote><p>hexo n 博客标题:创建文章<br>hexo clean | g(生成) | s(本地服务)</p></blockquote></li><li><p>安装插件</p><blockquote><p>npm install –save hexo-deployer-git</p></blockquote></li><li><p>修改_config.yml文件</p><blockquote><p>deploy:<br>type: ‘git’<br>repo: ‘<a href="https://github.com/Tab-Tan/Tab-tan.github.io.git&#39;" target="_blank" rel="noopener">https://github.com/Tab-Tan/Tab-tan.github.io.git&#39;</a><br>branch: ‘master’</p></blockquote></li><li><p>远程部署</p><blockquote><p>hexo d</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2020/07/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/07/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="第一个博客"><a href="#第一个博客" class="headerlink" title="第一个博客"></a>第一个博客</h2><p>也不知道说些什么 Java天下第一！</p><p>yeah~</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
